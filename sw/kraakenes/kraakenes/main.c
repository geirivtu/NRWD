#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include <util/delay.h>

#include "can.h"
#include "controller.h"
#include "current.h"
#include "motor.h"
#include "position.h"
#include "uart.h"



void init(void)
{
	motor_init();
	position_init();
	current_init();
	can_init();
	uart_init();
}

int main()
{
	init();

	/* Enabling external interrupt */
	sei();

	while(1)
	{
		control_controller();

		_delay_ms(150);
	}
}

ISR(CURRENT_vect)
{
	/* Overcurrent */
	motor_stop();

	_delay_ms(1000);

	current_startup();
	motor_start();
}

ISR(CANIT_vect)
{
	/* CAN-message received */
	unsigned char can_irq;
	volatile unsigned char canstmob;

	unsigned int id;
	unsigned char length;
	unsigned char controller;
	signed int setpoint;
	unsigned int K_p;

	/* Reading interrupt status register */
	can_irq = CANSIT2;

	/* Checking if interrupt is generated by MOb 1 and if interrupt is enabled */
	if (can_irq & (1<<SIT1) && CANIE2 & (1<<IEMOB1))
	{
		/* Selecting MOb 1 (reception) */
		CANPAGE = (1<<4);

		/* Reading message length */
		length = CANCDMOB & 0x0F;

		/* Reading message id */
		id = (((int)(CANIDT2))>>5) + (((int)(CANIDT1))<<3);

		switch(id)
		{
			case(ID_CONTROLLER):
				controller = CANMSG;
				if (!control_set_mode(controller))
				{
					can_message_t error_msg;
					error_msg.id = ID_ERROR;
					can_transmit(&error_msg);
				}
				break;
			case(ID_SETPOINT):
				setpoint = CANMSG;
				setpoint += (CANMSG<<8);
				control_set_setpoint(setpoint);
				break;
			case(ID_PARAMETER):
				K_p = CANMSG;
				K_p += (CANMSG<<8);
				control_set_parameter(K_p);
				break;
		}
	}

	/* Reading CAN MOb Status Register */
	canstmob = CANSTMOB;

	/* Clearing receive OK */
	CANSTMOB &= ~(1<<RXOK);

	/* Enabling reception */
	CANCDMOB = (1<<CONMOB1) | CAN_IDE;
}
