/*
 * nrwd_test.c
 *
 * Created: 04.09.2013 14:50:49
 *  Author: Geir
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include <util/delay.h>

#include "motor.h"
#include "position.h"
#include "current.h"
#include "controller.h"
#include "can.h"

int main(void)
{

	//motor_init();
	
	position_init();
	
	current_init();
	
	//control_set_mode(MODE_POSITION);
	
	//can_init();
	
	
	/* Setting PD6 to output */
	DDRD |= (1<<PD6); //Debug
	
	PORTD &= ~(1<<PD6);	 //debug
	PORTD |= (1<<PD6); //Debug

	/* Enabling external interrupt */
	sei();

	volatile uint16_t pos_temp;

    while(1)
    {
		
        //control_controller();
		control_position();

		_delay_ms(150);
    }
}




ISR(CURRENT_vect)
{
	/* Overcurrent */
	motor_stop();

	_delay_ms(1000);

	current_startup();
	motor_start();
}

/* CANUSB to Board connector
 * CAN_L: Serial pin 2 - Regulator board pin 1  (blue)
 * CAN_H: Serial pin 7 - Regulator board pin 2  (green)
 * CAN_GND: Serial pin 3 - 
 */
//
///*
//ISR(CANIT_vect)
//{
	///* CAN-message received */
	//unsigned char can_irq;
	//volatile unsigned char canstmob;
//
	//uint16_t id;
	//unsigned char length;
	//unsigned char controller;
	//int16_t setpoint;
	//uint16_t K_p;
//
	///* Reading interrupt status register */
	//can_irq = CANSIT2;
	//
	///* Clear interrupt flag, clear corresponding bit in CANSTMOB */
	//CANSTMOB &= ~(1<<RXOK);
	////CANSTMOB = 0;
//
//
//
	///* Checking if interrupt is generated by MOb 1 and if interrupt is enabled */
	//if ((can_irq & (1<<SIT1)) && (CANIE2 & (1<<IEMOB1)))
	//{
		///* Selecting MOb 1 (reception) */
		//CANPAGE = (1<<4);
//
		///* Reading message length */
		//length = CANCDMOB & 0x0F;
//
		///* Reading message id */
		//id = (((int)(CANIDT2))>>5) + (((int)(CANIDT1))<<3);
		//
		//setpoint = (CANMSG<<8)& 0xFF00;
		//setpoint += CANMSG;
		//control_set_setpoint(setpoint);
				//
		//can_message_t return_msg;
		//return_msg.id = 2;
		//return_msg.length = 2;
		//
		//uint16_t pos = position_read();
		//
		//return_msg.data[0] = pos>>8;
		//return_msg.data[1] = pos;
		//can_transmit(&return_msg);
		//
	//}
	//
	///* Enable reception */
	//CANCDMOB = (1<<CONMOB1) | CAN_IDE; //CAN_IDE = 0
	//
//}
//*/

		/*
		/*
		switch(id)
		{
			case(ID_CONTROLLER):
			controller = CANMSG;
			if (!control_set_mode(controller))
			{
				can_message_t error_msg;
				error_msg.id = ID_ERROR;
				can_transmit(&error_msg);
			}
			break;
			case(ID_SETPOINT):
			setpoint = CANMSG;
			setpoint += (CANMSG<<8);
			control_set_setpoint(setpoint);
			break;
			case(ID_PARAMETER):
			K_p = CANMSG;
			K_p += (CANMSG<<8);
			control_set_parameter(K_p);
			break;
		}
		*/
		