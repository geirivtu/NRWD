/*
 * nrwd_test.c
 *
 * Created: 04.09.2013 14:50:49
 *  Author: Geir
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdio.h>
#include <stdlib.h>
#include <util/delay.h>

#include "motor.h"
#include "position.h"
#include "current.h"
#include "controller.h"
#include "analog.h"
#include "can.h"



//! interrupt callback function for CAN receiver interrupt.
void setParameter( CAN_packet *p, unsigned char mob) // interrupt callback
{
	(void)mob;
	//PORTE^=p->data[0];
}

//! interrupt callback function for CAN receiver interrupt.
void setSetpoint( CAN_packet *p, unsigned char mob) // interrupt callback
{
	(void)mob;
	
	/*
	int16_t setpoint;
	setpoint = p->data[0] << 8;
	setpoint += p->data[1];
	*/
	
	int16_t speed = p->data[0];
	if(speed > 128) speed = -1;
	
	
	//control_set_setpoint(setpoint);
	control_set_setpoint(speed);
	//p->id= speed & 0xFFF;
	//can_tx( 14, p);
}



int main(void)
{

	BOOL ret;

	motor_init();
	
	position_init();
	
	current_init();
		
	//analog_init();
		
	can_init();

	ret=prepare_rx( 0, 0x150, 0x7ff, setParameter);
	//ASSERT( ret==0);

	ret=prepare_rx( 1, 0x151, 0x7ff, setSetpoint);
	//ASSERT( ret==0);
	
	control_set_mode(CONTROL_MODE_SPEED);
	
	/* Setting PD6 to output */
	
	DDRD |= (1<<PD6); //Debug
	
	PORTD &= ~(1<<PD6);	 //debug
	PORTD |= (1<<PD6); //Debug
	
	
	/* Enabling external interrupt */
	sei();

	volatile uint16_t pos_temp;
	
	volatile int16_t tmp = 0;
	
	CAN_packet *canTmp;
	canTmp->id = 0;
	canTmp->length = 1;
	canTmp->data[0] = 0;

    while(1)
    {
		
        //control_controller();
		control_speed_v2();
		//control_on_off();
		
		tmp = motor_read_speed();
		canTmp->data[0] = tmp;
	
		can_tx( 14, canTmp);

		
		_delay_ms(TIMESTEP);
    }
}


/* Overcurrent */
ISR(CURRENT_vect)
{
	motor_stop();

	controller_mode_t mode = control_get_mode();
	switch(mode){
		case CONTROL_MODE_ON_OFF:
			/* Set speed to 0 */ 
			control_set_setpoint(0);
			break;
		case CONTROL_MODE_POSITION:
			/* Set target position to current position */
			control_set_setpoint(position_read());
			break;
		
		case CONTROL_MODE_SPEED:
			/* Set speed to 0 */
			control_set_setpoint(0);
			break;
		
		default:
			/* Should not be here */
		
		break;
	}

	_delay_ms(1000);
	
	current_startup();
	motor_start();
}

/* CANUSB to Board connector
 * CAN_L: Serial pin 2 - Regulator board pin 1  (blue)
 * CAN_H: Serial pin 7 - Regulator board pin 2  (green)
 * CAN_GND: Serial pin 3 - 
 */
//
///*
//ISR(CANIT_vect)
//{
	///* CAN-message received */
	//unsigned char can_irq;
	//volatile unsigned char canstmob;
//
	//uint16_t id;
	//unsigned char length;
	//unsigned char controller;
	//int16_t setpoint;
	//uint16_t K_p;
//
	///* Reading interrupt status register */
	//can_irq = CANSIT2;
	//
	///* Clear interrupt flag, clear corresponding bit in CANSTMOB */
	//CANSTMOB &= ~(1<<RXOK);
	////CANSTMOB = 0;
//
//
//
	///* Checking if interrupt is generated by MOb 1 and if interrupt is enabled */
	//if ((can_irq & (1<<SIT1)) && (CANIE2 & (1<<IEMOB1)))
	//{
		///* Selecting MOb 1 (reception) */
		//CANPAGE = (1<<4);
//
		///* Reading message length */
		//length = CANCDMOB & 0x0F;
//
		///* Reading message id */
		//id = (((int)(CANIDT2))>>5) + (((int)(CANIDT1))<<3);
		//
		//setpoint = (CANMSG<<8)& 0xFF00;
		//setpoint += CANMSG;
		//control_set_setpoint(setpoint);
				//
		//can_message_t return_msg;
		//return_msg.id = 2;
		//return_msg.length = 2;
		//
		//uint16_t pos = position_read();
		//
		//return_msg.data[0] = pos>>8;
		//return_msg.data[1] = pos;
		//can_transmit(&return_msg);
		//
	//}
	//
	///* Enable reception */
	//CANCDMOB = (1<<CONMOB1) | CAN_IDE; //CAN_IDE = 0
	//
//}
//*/

		/*
		/*
		switch(id)
		{
			case(ID_CONTROLLER):
			controller = CANMSG;
			if (!control_set_mode(controller))
			{
				can_message_t error_msg;
				error_msg.id = ID_ERROR;
				can_transmit(&error_msg);
			}
			break;
			case(ID_SETPOINT):
			setpoint = CANMSG;
			setpoint += (CANMSG<<8);
			control_set_setpoint(setpoint);
			break;
			case(ID_PARAMETER):
			K_p = CANMSG;
			K_p += (CANMSG<<8);
			control_set_parameter(K_p);
			break;
		}
		*/
		