\documentclass[12pt,a4paper]{report}
%\usepackage[language]{babel}
\usepackage{listings}
\usepackage[norsk]{babel}
\usepackage{graphicx}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\author{Geir Turtum}
\title{Styresystem for kybernetisk håndledd}
\begin{document}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
 % frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
 % basicstyle=\footnotesize\ttfamily,
  %keywordstyle=\bfseries\color{green!40!black},
  %commentstyle=\itshape\color{purple!40!black},
  %identifierstyle=\color{blue},
  %stringstyle=\color{orange},
}

\lstset{language=C}

\maketitle


\chapter*{Oppgavetekst}

Instituttet har sammen med University of New Brunswick, Canada, stått sentralt i utviklingen av et motorisert protesehåndledd med unike kinematiske egenskaper. Det foreligger et maskinvaredesing og en prototyp av styresystemet, og dette systemet skal nå ferdigstilles og programmeres slik at protesen kan brukes i forsknigssammenheng. Sentrale systemegenskaper inkluderer kommunikasjon over en CAN-buss ved hjelp av protokollen PDCP, noe signalbehandling og styring av en børsteløs DC-motor.
 
\begin{enumerate}
\item Gi en kort oversikt over prosjektets bakgrunn og nåværende status, der du legger vekt på systemets tilstand relativt dets spesifikasjoner og tiltenkte anvendelse.

\item Foreliggende HW-design er basert på en enkelt mikrokontroller som skal stå for både motorkommutering, regulering, signalbehandling og kommunikasjonsprotokoll(er). Foreta en vurdering av om dette designet er egnet, med spesiell vekt på avbruddshåndtering og sanntidsaspekter. Gjør om nødvendig praktiske målinger for å underbygge din konklusjon.
 
\item Foreslå på bakgrunn av punkt 2 en maskin- og programvarearkitektur for systemet. Eksisterende løsninger bør gjenbrukes i den grad det er mulig og hensiktsmessig.

\item Implementer og test systemet så langt tiden tillater det.

\end{enumerate}
 
 
\chapter*{Sammendrag}

Denne prosjektoppgaven tar for seg design og utvikling av styresystemet til håndleddsprotesen NRWD(NTNU Rotary Wrist Device). NRWD ble i sin tid skapt på bakgrunn av doktorgradsavhandingen\cite{bib:stavdahl2002} til Øyvind Stavdahl.

Det har blitt skrevet flere prosjekt- og masteroppgaver\cite{bib:brattbakken,bib:kraakenes} om NRWDen hvor alle har hatt som mål å realisere en prototype av protesen, men på grunn av ulike årsaker ikke har fullført. Denne oppgaven baserer seg i hovedsak på arbeidet til Andreas Kråkenes \cite{bib:kraakenes}. Han har produsert maskinvare lagt ut på flerlagskort, samt skrevet programvare for testing av maskinvaremodulene, noe som la et meget godt grunnlag for videre arbeide. 

I denne prosjektoppgaven har styresystemet blitt ferdigstilt og det har blitt gjort anbefalinger til endringer i maskinvare der man har sett muligheter for forbedringer. 

Kommunikasjonen med protesen går over standard analoge og digitale elektroder og med den åpne protokollen PDCP(Prosthetic Device Communication Protocol). Implementeringen av protokollen er gjort av tidligere \mbox{NTNU} studenter\cite{bib:nordal,bib:zamojski} mens undertegnede har stått for integreringen av protokollen med protesens styresystem. 



\chapter*{Forord}

Jeg vil takke katten min Tom. 

\chapter*{Nomenklatur}

\begin{itemize}

\item NRWD - NTNU Rotary Wrist Device
\item PDCP - Prosthetic Device Communication Protocol
\item CAN - Controller Area Network
\item PWM - Pulse Width Modulation
\item UNB - University of New Brunswick
\item ISR - Interrupt Service Routine
\item LDO - Low Dropout Regulator
\item BLDC motor - Brushless DC electric motor


\end{itemize}



\tableofcontents


\chapter{Introduksjon}

\section{Bakgrunn for oppgaven}

Ideen bak protesen kommer fra Øyvind Stavdahls doktorgradsavhandling \cite{bib:stavdahl2002} fra 2002. I den viste eksperimenter med friske håndledd at en vinkel mellom lengdeaksen til underarm og rotasjonsaksen til håndleddet gjorde flere bevegelser enklere for brukeren å utføre. 

For å teste disse resultatene i praksis trenger man en 1-akse håndleddsprotese med design som muliggjør valgfri rotasjonsaske, se figur \ref{fig:wrist_angel}. Dette ble bygget som en del av mastergraden til Arthur Zink\cite{bib:zink} ved University of New Brunswick, Canada. Etter at mekanikken var ferdigstilt trengte man et styresystem for å styre protesen. 
 
\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/wrist_angel}
\caption{Vinkel mellom håndprotese og underarm kan varieres. Kilde: Styresystem for kybernetisk håndleddsprotese\cite{bib:kraakenes}}

\label{fig:wrist_angel}
\end{figure}

Det ble også funnet ut at dette var en god anledning til å teste ut den åpne protesestyringsprotokollen PDCP, som da var under utvikling hos UNB. Som krav i funksjonsspesifikasjonen til NRWDen ble det satt at den skulle kommunisere ved hjelp av denne protokollen. I tillegg skulle den kunne styres med de mer konvensjonelle analoge og digitale elektrodene. 


\section{Tidligere arbeid}

Realisering av styresystemet til protesen har hittil vært påbegynt i to mastergradoppgaver. Den siste av disse var skrevet av Andreas Kråkenes i 2011\cite{bib:kraakenes} kom langt på vei til å fullføre designet. Hovedgrunnen til at protesen enda ikke har blitt fullført skyldes at det første designet innholdt en alvorlig \mbox{arkitekturfeil} som hindret kommunikasjonen mellom de to mikrokontrollerene. Det ble forsøkt ordnet. Det endte med at man gikk man over til en løsning hvor en mikrokontroller skulle styre hele systemet. 

Da prosjektet ble overtatt av undertegnede, var alt av hardware designet og lagt ut på prototypekort. Programvare for å teste deler av systemet var ferdigskrevet, men koden var av varierene kvalitet og mye funksjonalitet var ikke implementert. Flest mangler var knyttet til de ulike regulatorene og implementasjonen av PDCP protokollen. 

To mastergradsstudenter ved NTNU\cite{bib:nordal,bib:zamojski} laget i 2012 en implementasjon av PDCP-protokollen. UNB hadde tildigere laget en implementasjon basert på PIC mikrokontrolleren, mens denne var designet for ATMELs AVR mikrokontrollere. Implementasjonen var designet for at det skulle være enkelt å overføre koden til ny maskinvare, noe som gjorde at den egnet seg godt for dette prosjektet.


\section{Mine bidrag}

Prosjektet ble startet med gå gjennom den overleverte maskinvaren og medfølgende driverkode modul for modul. Detaljer rundt hvordan de ulike modulene ble testet er beskrevet i kapittel \ref{chap:modTesting}.

Den overleverte koden var av varierende kvalitet. Koden var strukturert på et fornuftig vis, med en c-fil for hver maskinvare modul. Denne strukturen ble beholdt ut prosjektet. Selve driverkoden trengte en del mer arbeid. Det var skrevet nok til å teste basisfunksjonaliteten til hver modul, men måtte utvides med tilleggsfunksjonalitet før den kunne brukes. 

Under testing av maskinvaren ble det funnet muligheter for forbedringer i spenningsregulator og posisjonssensormodulene. Kapittel \ref{chap:modTesting} oppsumerer anbefalte endringer i maskinvaren.


Det første styressystemet som ble designet til NRWDen benyttet seg av to mikrokontrollere for å håndtere alle oppgavene. Denne arkitekturen gikk man bort fra da man fikk problemer med kommunikasjonen mellom de to kontrollerne og man gikk over til å bruke en mikrokontroller. Som en del av oppgaven ble det gjort grundige undersøkelser om den valgte mikrokontrolleren hadde nok ressurser til å styre systemet på egen hånd. Diskusjonen rundt dette er gjort i kapittel \ref{chap:interrupt}.

Ifølge funksjonsspesifikasjonene skal protesen ha minst tre forskjellige styringsmoduser, maks fart i valgt retning, posisjons- og hastighetsstyring. Koden til de forskjellige regulatorene ble alle skrevet fra bunnen av. For detaljer om hvordan de ulike regulatorene ble implementert, se kapittel \ref{chap:sw}.

På slutten av prosjektet ble styringssystemet integrert med kommunikasjonsprotokollen PDCP. Implementasjonen av protokollen var allerede gjort, jobben besto av å skrive om maskinvare abstraksjonslaget. Hvorfor og hvordan dette ble gjort, er beskrevet i kapittel \ref{chap:sw}.

\section{Utviklingsmetodikk og fremgangsmåte}

Hvordan dette prosjektet best skulle styres falt klart for meg fra begynnelsen av. Det er et maskin- og programvare system som allerede da det ble overtatt var delt opp i klare moduler. Som nevnt tidligere var det meste av maskinvare designet ferdig, mens den gjensto å ferdigstille programvaren. Det var også mye programvare som var skrevet av tidligere studenter som skulle flettes inn i prosjektet for ikke å reprodusere arbeide som var gjort tidligere. Det tenkes spesielt på lavnivå implementasjonen av PDCP protokollen som ble utviklet av  Andrzej Zamojski \cite{bib:zamojski} og  Andreas Nordal\cite{bib:nordal} samt programvare driverne til NRWDen skrevet av Andreas Kråkenes. 

Metoden min sin hovedlinje var i størst grad arbeide på prosjektet modul for modul, forsikre meg om at alt fungerte atskilt, for til slutt å sette modulene sammen til et komplett styresystem. Kort oppsummert var planen:

\begin{itemize}

\item Sette seg inn i bakgrunnsstoff for oppgaven.
\item Test hver maskinvare modul for seg, samt tilhørende programvare driver.
\item Sjekk om maskinvare og programvare oppfyller kravene satt av funksjonsspesifikasjonen.
\item Fullfør driverkoden til modulen som blir testet. 
\item Sett seg inn i implementasjonen av PDCP gjort av tidligere NTNU studenter. 
\item Integrere PDCP med styringssystemet.
\end{itemize}

Hvordan hver modul ble testet blir gått gjennom i kapittel \ref{chap:modTesting}.


Verktøyet som ble brukt for å budsjettere tiden og sørge for at man kom i mål med prosjektet til rigktig tid var, på anbefaling fra veileder, Gantt diagrammet. Figur \ref{fig:fig_gantt_diagram} viser framgangsplanen for de første ukene av prosjektet og hvorvidt planen ble overholdt. Gantt diagrammet var et nyttig verktøy å bruke, ikke bare ga det en klar oversikt over hvilke oppgaver man hadde igjen, men også hvorvidt man greide å overholde de tidsfrister man hadde satt. 


\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/fig_gantt_diagram}
\caption{Gantt diagram}
\label{fig:fig_gantt_diagram}
\end{figure}


Utviklingen av programvare ble gjort på en windows maskin med Atmel Studio 6. For versjonskontroll av kode og dokumenter falt valget på Git.

\section{Rapportens oppbygning}

Skrive om hva som kommer når? JA! Bluphbluhp

\chapter{NRWD Spesifikasjoner}

Dette kapittelet går gjennom funksjonsspesifikasjonene til NRWDen punkt for punkt. Spesifikasjonene beskriver kravene til systemet i sin hellhet fra de fysiske dimensjonene, kommunikasjons grensesnittet opp mot protesen, oppløsningen på de ulike sensorene, maks vinkel hastighet til protesen og så videre. 

Delkapittlene som følger tar for seg hver sin del av funksjonsspesifikasjonene. De beskriver hvike av kravene som er oppfylt, de som enda ikke er implementert og de som krever mer arbeid. Dette kapittelet beskriver systemet i sin nåværende tilstand og er ment for å hjelpe neste person som skal arbeide på prosjektet til å få en rask oversikt over hva som er gjort og hva som må gjøres. For noen av kravene vil statusen være kommentert som "Ikke relevant", dette gjelder de spesifikasjonene som omhandler de rent mekaniske sidene av systemet.

Ikke tatt med i dette kapittelet er de overordente funksjonsspesifikasjonene til NRWDen. De kan leses i det originale spesifikasjons dokumentet vedlagt denne oppgaven\ref{fig:funkspes}.

\section{Wrist Joint Function, WJF}

Beskriver det roterende leddet i protesen og hvordan festeanordningen til underarm og eventuell håndleddsprotese skal være manuelt justerbar. 

\begin{center}

	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} |}
	
	\hline
	Nr & Beskrivelse  & Status \\ \hline
	WJF-01 & The NRWD joint shall be a single, simple revolute joint which axis of rotation can be placed at an attitude with respect to the forearm and terminal device as spedcified in [1], Equations (7.4) and (7.5).  & Ikke relevant \\ \hline
	WJF-02 & The joint axis should be manually adjustable to other attitudes than that specified in WJF-01. & Ikke relevant \\ \hline
	WJF-03 & The joint shall enable an angular excursion of at least 180 degrees. The excursion should be unlimited. & Ikke relevant \\ 
	\hline
	 
	\end{tabular} 
\end{center}

\section{Wrist Motor Function, WMF}

Beskriver kravene til protesens vinkelhastighet og moment. Viktig å merke seg at det her settes krav til at motoren skal være beskyttet mot overopphetning i maskinvare.

\begin{center}
	\begin{tabular}{ | p{2cm} | p{8cm} | p{4cm} |}
	\hline

Nr & Beskrivelse & Status  \\ \hline
WMF-01 & The wrist joint (output of the gear train) shall have a maximum angular velocity of at least  1.4 rad/s (81 deg/s). The maximum velocity should be as high as possible. & Høyeste målte vinkel hastighet er målt til 2.72 rad/s (156 grader/sekund) \\ \hline
WMF-02 & The wrist joint should have a maximum torque of at least 34,3 mNm. & Ikke målt, men ifølge målinger gjort av Zink \cite{bib:zink} er stall torque på 59.6 mNm.  \\ \hline
WMF-03 & The motor shall have a maximum mechanical output power of at least TBC W. & NA  \\ \hline
WMF-04 & The motor shall be protected from overheating. The protection should be implemented by hardware. & Dette har blitt implementert i strømovervåkings modulen. \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Wrist Servo Function, WSF}

Beskriver kravet til posisjonssensoren og hvilke regulatorer som systemet skal implementere. 

\begin{center}
	\begin{tabular}{ | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status  \\ \hline
WSF-01 & The movements of the wrist joint shall be controllable according to the follwing modes:
\begin{itemize}
\item On/Off-mode
\item Position mode
\item Velocity mode
\end{itemize}
 & Alle kontrollerne er Implementert i controller.c  \\ \hline
WSF-01-01 & In On/Off-mode the motor shall be at rest or run at maximum speed (open-loop) in one  direction according to a given setpoint.  & Implementert ved bruk av PI-kontroller som kjører motoren nærmest mulig maksimum tillatte strømforbruk.  \\ \hline
WSF-01-02 & In position mode the joint angle shall be proportional  to a given angular setpoint.  & Implementert med PI-kontroller. \\ \hline
WSF-01-02-01 & The WSF shall include an absolute position sensor. This sensor shall provide no less than 10 bits resolution per revolution. & En 12-bits magnetisk enkoder er brukt.  \\ \hline
WSF-01-03 & In velocity mode the joint angular velocity shall be crudely proportional to a given velocity setpoint. & Implementert med PI-kontroller. \\ \hline
WSF-01-03-01 & The WSF shall include a velocity sensor or estimator. & Hastighet er estimert ved hjelp av hall elementene. \\ \hline
WSF-02 & The movements of the wrist joint should be controllable according to the follwing modes:  
\begin{itemize}

\item Torque mode
\item Impedance mode
\end{itemize}
 & Ikke implementert.  \\ \hline
WSF-02-04 & In torque mode the motor torque shall be proportional to a given torque setpoint.  & Ikke implementert.  \\ \hline
WSF-02-04-01  & The WSF should include means for monitoring motor current.  & Implementert, se strømovervåknings modulen.  \\ \hline
WSF-02-05 & In impedance mode the mechanical impedance of the joint shall be determined by a given impedance setpoint  & Ikke implementert.  \\ \hline
WSF-03 & WSF shall provide an interface to WCF through which the modes (described in WFS-01 to WSF-02) can be selected and relevant parameters can be set, and through which WSF can report relevant state variables TBD. & Koden er lagt opp for at dette enkelt kan bli implementert når kommunikasjons spesifikasjonen er klargjort.  \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Wrist Communication Function, WCF}

Beskriver hva slags kommunikasjonsgrensesnitt systemt skal implementere. 

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status \\ \hline
WCF-01 & The NRWD shall have a two-wire Proximal Communication Interface (PCI) and a two-wire Distal Communication Interface (DCI). & Implementert ved CAN-bus. \\ \hline 
WCF-02 & The PCI shall be configurable so that it implements two (0V, 7,2V) analog input lines or a bidirectional twowire CAN interface with the PDCP protocol(Losier,2009). & Implementert ved CAN-bus og PDCP-protokollen. \\ \hline
WCF-02-01 & The analog input lines shall be able to sample both lines at a rate of 1 kHz. The sampling rate should be as high as 2 kHz. & Implementert i analog.c \\ \hline
WCF-03 & The DCI shall be configurable so that it implements two (0 V, 7.2 V) analog output lines or a bidirec[1]onal two-wire CAN interface with the PDCP-protocol.  & Implementert ved CAN-bus og PDCP-protokollen. Implementasjonen av PDCP-protokollen er ikke ferdig.  \\ \hline
WCF-04 & The WCF shall be configurable to an all-Analog mode, with the PCI as an analog input interface and the DCI as an analog output interface. & Analog output interface ikke implementert i verken HW eller SW.  \\ \hline
WCF-05 & The WCF shall be configurable to an all-digital mode, with the PCI and the DCI acting as bidirectional CAN bus interfaces. & Implementert. CAN buss trenger bare et tilkoplingspunkt.  \\ \hline
WCF-07 & The WCF should be configurable to a hybrid mode in which the PCI acts as two analog input lines while DCI acts as a bidirectional CAN interface (cf. WCF-01) & Ikke implementert i HW.  \\ \hline
WCF-10 & The WCF shall include a serial interface for downloading software and for debugging/diagnostic purposes. & Implementert ved bruk av JTAG.  \\ \hline
WCF-11 & WCF shall implement an interface to WSF according to WSF-03. &  Se WSF-03. \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Wrist Power Function, WPF}

Beskriver kraftforsyningen til systemet.

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status \\ \hline
WPF-01  & The WPF shall accept external power in the form of an unregulated two-wire DC supply. & Implementert ved brukt av intern spenningsregulator. \\ \hline
WPF-02 & The NRWD shall tolerate and run normally when powered with a voltage in the range (6 V, 12 V). The range of usable voltages should be as wide as (5 V, 18 V). &  Valgte spenningsregulator opererer normalt innenfor området (7V, 18V). Det er anbefalt å gå over til en Low Droupout Regulator for å tilfredstille kravet.  \\ \hline
WPF-03 & The NRWD shall tolerate supply voltage in the range (0 V, 12 V) without exhibiting unpredictable behaviour and without getting damaged. & Implementert ved bruk av brown out deteksjon internt på AVRen. [todo] \\ \hline
WPF-04 & The NRWD should automatically limit its motor current to a level that does not reduce the supply voltage below the interval given in WPF-01. & Ikke implementert.  \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Proximal Attachment Function, PAF}

Beskriver festeanordningen og grensesnittet mellom NRWDen og underarmen. 

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status\\ \hline
PAF-01 & The PAF shall comprise two parts, the proximal of which is adapted to be permanently attached to the forearm socket and the distal permanently attached to the wrist unit. The parts must ?mate? to form a mechanically stable connection while also being detachable. & Ikke relevant\\ \hline
PAF-01-01 & The proximal part of the PAF shall be hollow to allow access to the space within the socket proximally to the wrist. & Ikke relevant\\ \hline
PAF-02 & PAF disconnection should be possible with hand or a simple tool, e.g. a screwdriver. &  Ikke relevant\\ \hline
PAF-03 & The PAF shall include a four-wire electric coupling, preferably mechanically integrated with the PAF itself. & Ikke implementert i prototype hardwaren. \\ \hline
PAF-03-01 & The PAF electrical coupling shall include at least two power supply wires/contacts capable of transferring a constant current of 4 A per wire. & Ikke implementert i prototype hardwaren. \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Distal Attachment Function, DAF}

Beskriver festeanordningen og grensesnittet mellom NRWDen og en eventuell håndprotese. 

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline
Nr & Beskrivelse & Status\\ \hline
DAF-01 & The DAF should comprise two parts, the proximal of which is permanently attached to the wrist and the distal permanently attached to the terminal device. The parts must ?mate? to form a mechanically stable connection while also being detachable. &  Ikke relevant\\ \hline
DAF-02 & The DAF shall include a four-wire electric coupling, preferably mechanically integrated with the DAF itself. & Ikke implementert i prototype hardwaren. \\ \hline
DAF-02-01 & The DAF electrical coupling shall include at least two wires/contacts capable of transferring a constant current of 2 A per wire, and these wires shall be connected to the power supply wires from PAF. & Ikke implementert i prototype hardwaren. \\ \hline
DAF-02-02 & The DAF electrical coupling should be rotatable without twisting the wires. & Ikke implementert i prototype hardwaren. \\ 
	\hline
	\end{tabular} 
\end{center}

\chapter{Mekanikken}

Mekanikken i protesen er et resultat av masteroppgave skrevet ved universitetet i  New Brunswick, Canada. Dette ble gjort på oppdrag fra Øyvind Stavdahl for å teste resultatene fra sin doktorgradsavhandling i praksis. Mekanikken består av to seksjoner, den proksimale og distale(henholdsvis seksjonen nærmest underarmen og den lengst unna). De to seksjonene kan rotere fritt mot hverandra ved hjelp av et kulelager. Selve bevegelsen er drevet av en børsteløs DC-motor som er koplet til et girtog med utveksling 120:1 \cite{bib:zink}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/mekanikk}
\caption{Oversiktbilde over den indre mekanikken til protesen. Figur hentet fra \cite{bib:zink} }
\label{fig:mekanikk}
\end{figure}


Under testing av motordriveren ble det funnet at det, ved en forsyningsspenning på 12V, måtte til en dutycycle på oppmot 60\% for å i det hele tatt bevege mekanikken. Ved rundt 80\% dutycycle ble strømmen til motoren kuttet av strømovervåkingsmodulen da strømmen gjennom motoren oversteg maksimum grensen. Denne grensen er satt i maskinvare for å unngå at motoren blir ødelagt på grunn av overopphetning. Dette ga regulatoren et veldig lite rom å jobbe innenfor noe som gjorde implementasjonen av posisjon og hastighetskontrolleren meget vanskelig. 

Mekanikken ble tatt med til mekaniske verksted ved NTNU for å se om de kunne løse problemet. Det viste seg at aksen til det minste tannhjulet var bøyd noe som førte til ekstra friksjon i systemet. Tannhjulet det er snakk om er det som er koblet til Faulhaber girboksen i den distale seksjonen, se figur \ref{fig:mekanikk}. Verkstedet fikk bøyd det til slik at det gikk fra å ha en kast på 0.22 mm til 0.03 mm. Dette reduserte friksjonen betraktelig og mekanikken kunne nå beveges med en dutycycle ned mot 40\%. 

Da mekanikken ble undersøkt ble det også funnet at kulelageret i protesen begynte å bli slitt noe som førte til yterligere friksjon i systemet.

Om rettingen av giraksen løser problemet på langt sikt vil vise seg med tiden. At problemet i det hele tatt har oppstått tyder på at mekanikken ikke er riktig dimensjonert for de krefter den kan bli utsatt for. En teori på hvordan problemet kan ha oppstått er at man har vridd på den distale seksjonen, noe som påfører store krefter på den indre mekanikken. Dette tyder på at mekanikken kan ha behov for en ny revisjon før den er robust nok til å kunne brukes i eksprimenter.

For fremtidig bruk er det lagt ved en oversikt over rotasjonshastigheten til protesen ved forskjellige dutycycler etter at mekanikken var rettet av verkstedet, se vedlegg \ref{tab:velocity}. Denne kan brukes for å se om problemet har gjenoppstått.


\chapter{Interrupt diskusjon}
\label{chap:interrupt}

Hvorfor diskutere interrupt

Problemer med gamle arkitektur

\section{Bakgrunn}

Tidligere forsøk på å realisere styresystemet til NRWDen har brukt to mikrokontrollere. Den ene skulle brukes til motor kommuteringen mens den andre skulle håndtere alle de andre oppgavene som regulering og kommunikasjon. Da systemet ble testet oppsto det problemer med kommunikasjonen mellom mikrokontrollerene og selv etter mye testing fant man aldri årsaken til problemet. Dette førte til at man gikk over til en arkitektur som brukte en enkelt mikrokontroller.

Ny arkitektur

Spørsmålet var da om den valgte mikrokontrolleren, AT90CAN128 kjørende på 16 MHz, var nok til å håndtere alle oppgaver som før skulle blitt utført av to mikrokontrollere. Dette kapitellet tar for seg denne problemstillingen. 

\section{Et interrupt drevet system}

Hva slags system er dette her? Soft real time? 

Forklar hvordan systemet er bygget på interrupts



Så hva slags type system er det som styrer protesen? Styringssystemet er nesten helt og holdent interrupt drevet. Bortsett fra regulatoren som blir kjørt inni main while loopen er alt annet styrt med interrupts. Motorkommuteringen, kommunikasjonsprotokollen, fartsestimeringen, posisjonsavlesningen og strømovervåkingen blir alle styrt gjennom interrupts. Hver av disse funksjonene krever at tiden mellom et interrupt blir generert og mikrokontrolleren går inn i tilhørende ISR(Interrupt Service Routine) ikke overstiger en viss lengde. 

Om et interrupt ikke blir håndtert innenfor tidsfristen en eller flere ganger vil systemet i beste fall bli mindre nøyaktig, i verste fall vil det slutte å fungere. Som et eksempel kan man ta for seg posisjonssensoren. Posisjonen er proporsjonal med dutycyclelen til sensor signalet. Denne leses av ved å måle tiden mellom positiv og negativ flanke på signalet, hver endring i nivå på signalet genererer et interrupt. Hvis tiden det tar for mikrokontrolleren å behandle interruptet tar lengere tid enn forventet vil posisjonen bli feil avlest. 






Hvorfor er det viktig at alle interrupts blir håndtert

Hvordan håndterer AVR interrupts

KOrt om hvilke interrupt systemet må håndtere








Som nevnt ovenfor, om ikke systemet har nok resurser til å håndtere alle interruptene som kommer vil man risikere at man får et system som virker tregt og uresponsivt eller slutter å virke. For å kunne gi en garanti om at dette ikke ville skje ble systemet analysert for tidsbruk i interrupt rutiner. 

Typen interrupts som systemet skal håndtere kan deles inn i to typer, periodiske og aperiodiske. 

De periodiske er som følger:
\begin{itemize}
\item HALL\_X\_vect - Trigger hver gang en av de tre hall sensorene i motoren skifter nivå
\item TIMER3\_CAPT\_vect - Trigger på hver flanke til PWM signalet fra posisjons sensoren
\item TIMER0\_OVF\_vect - Brukes til å beregne hastigheten til motoren
\end{itemize}


De aperiodiske er:
\begin{itemize}
\item CANIT\_vect - Trigger hver gang det kommer en CAN melding
\item CURRENT\_vect - Trigger når maskinvaren slår av strømmen til motoren
\item RESET 
\end{itemize}


For å analysere systemet ble varigheten til hver interrupt målt. Et interrupt i mikrokontrolleren består av tre deler. Det er kontektsskiftet hvor mikrokontrolleren lagrer unna stacken før man går inn i ISRen, arbeidet som blir utført inni rutinen og gjennopprettingen av stacken i det man forlater den. Tiden det tar for mikrokontrolleren å utføre de to konteksskiftene er et fast antall instruksjoner, det faktiske tallet finnes i mikrokontrollerens datablad \cite{bib:at90can}. Varigheten til hvert interrupt ble målt ved å sette en GPIO-pinne høy ved inngangen av interruptet og lav i det den gikk ut og lese av oppetiden på oscilloskopet. Se tabell \ref{tab:interrupt} for oppsumering av tidsbruk til de periodisk interruptene.

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{ | l | l | l | l |}
		\hline
	Navn & Varighet ($\mu$s) & Maks frekvens & Tidsbruk per sekund($\mu$s) \\ \hline
	HALL\_X\_vect  & 4.5 & 3600 & 16200  \\ \hline
	TIMER3\_CAPT\_vect  & 4.8 & 490 & 2352 \\ \hline
	TIMER0\_OVF\_vect  & 3.2 & 61 & 196 \\ \hline
	Totalt &  &  & 18742  \\
		\hline
		\end{tabular} 
	\end{center}
	\caption{Viser varigheten til hvert interrupt, hvor mange ganger de blir kjørt i sekundet og totalt tidsbruk per sekund. }
	\label{tab:interrupt}
\end{table}

Vi ser av tabell \ref{tab:interrupt} at mikrokontrolleren bruker mindre enn 2\% av tiden inni en interrupt rutine. Det gir rikelig med tid til å håndtere kontrolloopen som kjører utenfor interruptene. Derimot så garanterer det ikke at alle interrupts vil bli håndtert innenfor rimelig tid. I et tilfelle hvor en eller flere av modulene genererer et interrupt samtidig kan dette føre til midlertidige feil i systemet. Siden dette ikke er et hard sanntidssystem, hvor overskridelsen av en tidsfrist hadde knekt systemet, er disse midlertidige feilene akseptable siden med alle de forskjellige ISRene vil problemet være løst ved neste interrupt. Da ISRene opptar under 2\% av prosseror syklene og de alle operere ved ulike frekvenser vil kolisjon mellom to eller flere ISR være et sjeldent fenomen. 

Det ble også undersøkt om mikrokontrolleren er rask nok til å håndtere kommuteringen av motoren. En den for treig vil den ikke kunne kommutere raskt nok til at motoren oppnår den ønskede hastighet. ATMELs applikasjonsnote AVR452 som tar for seg motor styring av børste løse DC motorer ved bruk av AT90CAN mikrokontrolleren. Den setter en teoretisk maksgrense ved 3'478'000 rpm ved 8 MHz, da maksfarten til NRWD motoren er satt til 3600 rpm og mikrokontrolleren kjører på 16 MHz befinner vi oss godt innenfor kravene. 




\chapter{Maskinvaretesting og diskusjon}
\label{chap:modTesting}

[TODO]  Dessverre var skjemategningen bare tilgjengelig i pdf format så utlegg må gjøres på nytt når kretsen skal miniatyriseres for å få plass inni protesen.


Dette kapittelet går igjennom maskinvaren som dette prosjektet har basert seg på. Det blir forklart hvordan hver modul har blitt testet og eventuelle forslag til forbedringer blir gitt. 

Dette prosjektet startet ikke på bar bakke, men bygger videre på arbeidet til flere studenter. Således var det mye dokumentasjon, maskinvare og programvare som måtte gjennomgåes før det kunne bygges videre på. Det tenkes her spesielt på arbeidet til Andreas Kråkenes som var siste student som arbeided på NRWDen. Det var han som sto for utlegg og produksjon av maskinvareprototypen, se figur \ref{fig:nrwd_prototype}, som har blitt brukt under dette prosjektet. 

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/nrwd_prototype}
\caption{Prototypen av NRWD maskinvaren produsert av Andreas Kråkenes, her vist tilkoplet protese mekanikken.}
\label{fig:nrwd_prototype}
\end{figure}

Alt av overlevert maskin- og programvare ble gjennomgått og testet modul for modul for å se om det fungerte i henhold til det som sto i Kråkenes' oppgave \cite{bib:kraakenes}. Domumentasjonen av maskinvaren besto av tekstlige beskrivelser gjort i oppgaven samt vedlagte skjemategninger. Før arbeidet startet ble en kort testplan for hver modul utarbeidet, den ble laget slik at da alt i planen var testet skulle man være sikker på at maskin- og programvaren for valgt modulen oppførte seg som forventet. Under følger resultatene av testingen, samt en diskusjon rundt hver modul. For flere detaljer rundt maskinvaren, se Kråkenes' oppgave\cite{bib:kraakenes}.

\section{Mikrokontroller}

Styringen av protesen er gjort med en AT90CAN128 ATMEL AVR mikrokontroller. Opplasting av programvare og debugging ble gjort over JTAG via ATMELs programmerinsverktøy, JTAGICE 3. Det ble opprettet kontakt med AVRen og alt fungerte som forventet. 

\section{Spenningsforsyning}

Ifølge funksjonskravet WPF-02 skal NRWDen operere normalt når den blir drevet av en spenningsforsynning mellom 6 og 12V. Spesifikasjonene sier ikke noe om hvilke spenninger som skal brukes internt, men den valgte mikrokontrolleren trenger 4.5V for å kjøre på 16MHz. Det har derfor blitt valgt at den eksterne spenningsforsyningen skal reguleres ned til 5V.  

Spenningsregulatoren brukt i NRWDen er en linær regulator som i henhold til databladet gir ut 5V +- 0.2V ved inngangsspenninger 7-20 V. Det er viktig at NRWDen kan operere på spenninger ned til 6V siden de vanligste batteriene som er brukt i slike proteser gir ut en spenning som kan gå ned til minst 6V. Da differansen mellom inngangs- og utgangsspenning kan være så lav som 1V er anbefales det å gå over til å bruke en LDO (Low Dropout Regulator). En LDO er spesielt designet for å operere under akkurat slike forhold. Et eksempel på en LDO som kan brukes er LF50CDT fra STMicroelectronics.  



\section{Posisjonsmåling}



Ifølge funksjonskravet WSF-01-02-01 skal NRWDen være utstyrt med en absolutt posisjonssensor med en oppløsning på minst 10 bit. 

Den nåværende løsningen er en magnetisk enkoder. Den leser av magnetfeltet til en magnet festet på den distale delen av NRWDen. Sensoren gir ut et PWM signal hvis dutycycle er proporsjonalt med vinkelen til magnetfeltet på sensoren, se figur \ref{fig:posisjon_hel_periode}.  Hver flanke på PWM-signalet generer et interrupt og tiden mellom en stigende og synkende flanke blir målt av mikrokontrolleren. 

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/posisjon_hel_periode}
\caption{Utgangen til posisjonssensoren målt med oscilloskop}
\label{fig:posisjon_hel_periode}
\end{figure}

Problemet med dette oppsettet kommer ved vinkler nær 0 og 360 grader. Ved disse vinklene vil tiden mellom to flankeendringer være under 1 $\mu$s, se figur \ref{fig:posisjon_min_periode}. Som beskrevet i kapittel \ref{chap:interrupt} tar dette interruptet 4.8 $\mu$s å fullføre. Dette vil si at det andre interruptet som kommer enten ikke vil bli behandlet eller bli behandlet for sent noe som vil gi feil avlest vinkel. 

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/posisjon_min_periode}
\caption{Utgangen til posisjonssensoren ved lavest dutycycle}
\label{fig:posisjon_min_periode}
\end{figure}

Forløpig er problemet løst i programvare, men en bedre løsning ville vært å lavpassfiltrere PWM-signalet for så å lese av vinkelen med en ADC. Dette løser ikke bare problemet med feil avlesning av vinkel, men det vil også redusere antall interrupts som mikrokontrolleren må behandle. PWM-signalet har en frekvens på 245 Hz, noe som gir 490 interrupts i sekundet. Ved bruk av et lavpassfilter og en ADC vil man bare trenge å kalkulere posisjonen hver gang posisjonsregulatoren skal kjøre. GPIO pinnene på mikrokontrolleren har allerede mulighet for å aktivere en intern pullup motstand noe som betyr at den eneste eksterne komponenten som kreves for å lage et lavpassfilter er en kondensator med passende verdi.

\section{Motordriver}

Protesens bevegelse er drevet av en børsteløs DC-motor med innebydge Hall sensorer. Ved å lese av Hall sensorene vet man posisjonen til motoraksen og kan utifra det vite hvilket pådragsmønster man skal gi motoren får å få den til å rotere. Utgangen til Hall sensorene er digitale og er koplet opp mot hver sin interrupt linje slik at det blir generert et interrupt hver gang utgangen skifter nivå. 

Ifølge funksjonskravet WMF-01 skal protesen minst ha en maksimums omdreiningshastighet på 81 grader/sek. Ifølge Zink\cite{bib:zink} er motoren giret ned med en ratio på 800:1, se tabell \ref{tab:drive_train}. Dette stemmmer ikke med protesen brukt i dette prosjektet da diameterene til drivhjulene fra motor til Faulhaber planetary gear ikke er som spesifisert hos Zink. Faktiske målinger viser at den totale gir ration til protesen er på 333:1. 

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/drive_train}
\caption{Tabellen viser girtoget til motoren slik det originalt var ment, stemmer IKKE med den mekanikken brukt i dette prosjektet. Tabell hentet fra Zink, Design of a compact, reconfigurable, prosthetic wrist\cite{bib:zink}.}
\label{tab:drive_train}
\end{figure}

For å oppnå ønsket vinkelhastighet tilsvarer dette en motorhastighet på 4496 rpm, se formel \ref{eq:motor_rpm}. Ifølge motordatabladet \cite{bib:bldc} er makshastigheten til motoren 35600 rpm noe som faller godt innenfor kravet. 

\begin{equation}
 \frac{81 \text{grader/sekund} }{360 \text { grader}}  \times 333 \times 60 \text{ sekund} = 4495.5 \text{ rpm}
	\label{eq:motor_rpm}
\end{equation}

Da motorens hall sensorer genererer 6 interrupt per omdreining vil mikrokontrolleren måtte kunne håndtere minst opptil 3560 interrupts i sekundet, se formell \ref{eq:interrupt}. 

\begin{equation}
 \frac{35600 \text{ rotasjon/min}}{60 \text { sek/min}}  \times 6 \text{ interrupts/sek} = 3560 \text{ interrupts/sek} 
	\label{eq:interrupt}
\end{equation}

En testbenk ble satt opp for å teste om mikrokontrolleren greie å håndtere alle motor sensor interruptene. Et Arduino brett ble brukt for å simulere utgangene til motorens Hall sensorer med en hastighet som tilsvarte 400'000 rpm. Arduino brettet var programmert til å påføre et bestemt antall interrupts som mikrokontrolleren telte. Da antallet registrerte interrupts stemte med antallet sendt ut ved disse hastighetene kunne man være sikker på at mikrokontrolleren ville greie å håndtere kommuteringen av motoren ved de faktiske hastighetene. 


\section{Strømovervåkning}

Ifølge funksjonskravene WMF-04 og WSF-02-04-01 skal motoren være beskyttet mot overopphetning i maskinvare og man skal kunne måle hvor mye strøm motoren trekker. Overopphetning skjer når motoren trekker for mye strøm. Utregningen av den maksimalt tillatte strømmen er gjort tidligere av Kråkens\cite{bib:kraakenes} itifra motorens datablad\cite{bib:bldc} og er satt til 145 mA. 

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/fig_strommaaling}
\caption{Skjemategning til strømovervåknings modulen. Figur hentet fra Kråkenes\cite{bib:kraakenes}}
\label{fig:fig_strommaaling}
\end{figure}


Motoren får strøm gjennom et 20 KHz PWM-signal som går gjennom den 1 ohms store målemotstanden før det går til jord. Spenningen over målemotstanden blir lavpasfiltrert og forsterket av en operasjonsforsterker før det går inn på en komparator krets som setter en SR-vippe, denne sørger for å slå av strømforsyningen til motoren når den trekker mer enn den maksimalt tillatte strømmen. SR-vippen kan bli resatt av mikrokontrolleren. Utgangen til operasjonsforsterkeren er også koplet til en ADC-pinne på mikrokontrolleren. Strømmen kan da måles ved å lese av ADCen o

Som vi ser av skjemategningen går motorstrømmen over den 1 ohms store målemotstanden. Deretter blir signalet lavpassfiltrert, motoren er styrt med en 20 kHz PWM signal, og forsterket opp av en operasjonsforsterker. For å få strømovervåkning har utgangen fra operasjonsforsterkeren blitt lagt ut til en av mikrokontrollerens ADC innganger. Strømmen gjennom motoren kan da leses av ved å bruke formel \ref{eq:strom}. 

\begin{figure}[h]
\begin{lstlisting}
	/* Multiply K with ADC value to get current in 1/10 uA 
	* ADCref = 5 V
	* Aopamp = 15.7 (opamp gain)
	* K = ADCref * (100'000/1024)/(Aopamp) = 31
	*/
	uint16_t K = 31; 
	current_mA = (K*ADC)/100; //divide by 100 to get mA 
\end{lstlisting}
\label{eq:strom}
\end{figure}

For å teste kretsen ble det brukt en variabel strømforsyning. Modulen skrudde av strømmen ved riktig verdi og mikrokontrolleren leste av strømmen med stor nøyaktighet. 

\section{CAN}

Ifølge funksjonskravet WCF-02 skal protesen være styrt over PDCP-protokollen som baserer seg på CAN for å sende og ta imot meldinger. Prototypekortet er utstyrt med en CAN-tranceiver som er koplet opp mot mikrokontrolleren. CAN modulen ble testet med et USB til CAN modul som gjorde det enkelt å sende meldinger fra PCen. Mikrokontrolleren ble testet ved hastiheter opp til 125 kbit hvor alt fungerte som forventet. 



\section{Diverse}

Diskuter tilkoblingskontakter her


\chapter{Programvare implementasjon}
\label{chap:sw}

Hva står i dette kapittelet?

Dette kapittelet beskriver hvordan programvaren er bygget opp og satt sammen. I tillegg diskuteres modulariseringen av koden og fallgruver ved programmering av et interrupt drevet system. Underkapittlene beskriver hva hver modul gjør og hvordan den forholder seg til resten av koden. 

Hvordan koden har blitt skrevet

Koden kan deles opp i to hoveddeler. Driverkoden til NRWDen som er maskinvareavhengig og høy nivå laget(HLL) til PDCP-protokollen. Driverkoden er igjen delt opp i deler etter de ulike maskinvaremodulene. 


Hvilke deler er skrevet av meg?

En oversikt over programvaren kan ses i figur \ref{fig:code_class_diagram}. Her vises alle de ulike modulene og hvem som inkluderer hvem. 

Viktigst! Forklar hvordan koden er bygd opp! Hva trenger neste utvikler å vite?



\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/code_class_diagram}
\caption{Klassediagram som viser innholdet i og avhengighetene mellom de ulike programvare modulene.}
\label{fig:code_class_diagram}
\end{figure}


Hva er faren ved å bruke interrupts? 

Hva er gjort i forhold til race conditions?

Optimalisering? Burde optimalisere for fart.

Hvor mye av minnet bruker koden.

Programflyt?


Detaljer rundt hver modul? 

\section{motor}

Motor-modulen sørger for kommuteringen av motoren og vinkelhastighetsavlesning.

Pådraget til motoren settes ved motor\_set\_speed(). Denne funksjonen setter dutycyclen til PWM-signalet som driver motoren. Siden strømmen levert av dette signalet varierer med forsyningsspenningen setter man ikke vinkelhastigheten direkte. Kontrolering av farten til protesen skjer i controller modulen. 

Etter at duty cyclen er satt vil Hallsensor interrupt rutinene automatisk ta seg av kommuteringen av motoren. En timer overflow interrup rutine vil kontinuerlig oppdatere vinkelhastigheten til protesen slik at den til enhver tid kan leses av med motor\_read\_speed().

\section{current}

Current-modulen bruker mikrokontrollerens ADC til å lese av strømmen som går gjennom motoren. Interruptrutinen, CURRENT\_vect, som blir kjørt når maskinvaren skrur av strømmen til motoren ligger ikke her, men i main c-filen. Dette er fordi CURRENT\_vect benytter seg av flere av modulene til å rydde opp i systemet etter at motorstrømmen har blitt skrudd av. 

\section{position}

Position-modulen setter opp en timer til "input capture mode". Den er satt opp til å generere et interrupt ved endring i flanken på signalet fra posisjonssensoren. Ved en positiv flanke starter timeren og ved negativ flanke blir telleren i timeren lagret. Utifra verdien til telleren blir vinkelposisjonen til protesen regnet ut og lagret i en global variabel. Denne kan til en hver tid bli lest ut av position\_read funksjonen.  

\section{controller}

Ifølge funksjonskravet WSF-01 skal bevegelsen til protesen være kontrollerbar gjennom de følgende måtene:

\begin{itemize}
\item On/Off-mode
\item Position mode
\item Velocity mode
\end{itemize}

Disse finnes implementert i controller.c som henholdsvis control\_on\_off(), control\_position() og control\_speed(). Utfordringen ved designet av regulatorene var at strømmen til motoren automatisk ble slått av hvis den oversteg en forhåndsbestemt maksgrense. En regulator som ikke hadde tatt hensyn til dette vil ikke ha gitt en god brukeropplevelse da protesemotoren ville skrudd seg av med gjevne mellomrom.  

Funksjonskravet WSF-01-01 sier at On/Off-mode skal være kjørt i en open-loop kontroller. På grunn av overnevnte grunner har den istedenfor blitt kjørt i en PI-kontroller. Denne regulerer strømmen gjennom motoren tett opptil den maksimale grensen for å oppnå høyest mulig vinkelhastighet. 

Fartsregulatoren løser begrensingen i motorstrøm ved å brukke en dobbel PI-regulator. Den ytre sløyfen tar inn vinkelhastighet og setter strøm referansen til den indre sløyfen. Den indre setter pådraget til motoren basert på strømreferansen og sørger samtidig for at strømmen ikke går over den maksimalt tillate verdien. 

Posisjonsregulatoren fungerer på samme måte som fartsregulatoren, bortsett fra at den ytre sløfen tar inn vinkelposisjonen til protesen. 

I alle regulatorene er utregningen av integralleddet uavhengig av frekvensen som regulatoren kjører på. Dette betyr at om frekvensen til regulatorløkken blir endret så må regulatorene justeres. Frekvensen til regulatorløkken er styrt med en busy-wait forsinkelse funksjon, se figur \ref{code:while_regulator}. Denne typen forsinkelsesfunksjoner registrerer ikke når man er inni en interruptrutine. Dette betyr at regulatorløkken blir forsinket med så mye tid man bruker inni hver av interruptrutinene. Da mikrokontrolleren bruker mindre enn 2\% av tiden sin inne interruptrutiner vil dette ikke medføre noen problemer for regulatoren. 

\begin{figure}[h]
\begin{lstlisting}
    while(1)
    {
	control_controller();
	_delay_ms(TIMESTEP);
    }
\end{lstlisting}
\label{code:while_regulator}
\end{figure}

Verdien til P- og I-leddet til de tre regulatorene ble funnet vet å prøve å se hva som virket bra. De gir god regulering, men det kan med fordel brukes mer tid for å få enda bedre respons. 

Funksjonskravet WSF-03 setter krav til at man skal kunne skifte både regulatortype og vedien til regulatorparametrene gjennom PDCP-protokollen. Bytte av regulatortype gjøres gjennom control\_set\_mode() funksjonen. For å bytte parametere må man først velge regulator gjennom nevnte funksjon, deretter kan man sette P- og I leddet ved control\_set\_parameter() funksjonen. 


\section{analog}


Funksjonskravet WCF-04 sier at NRWDen skal kunne styres ved å bruke analoge elektroder. Dette er den normale måten å styre myoelektriskeproteser. Videre sier WCF-02-01 at de analoge linjene skal kunne samples ved minst 1 kHz. Myoelektriske signaler har en båndbredde på 500 Hz. 

Analog-modulen ble ikke ferdig implementert i dette prosjektet. Hadde den blitt ferdig hadde den hatt de samme oppgavene som PDCP-modulen, ta imot eksterne signaler og styre protesen. 

Da kommunikasjonen ville vært rent analogt ville den ikke hatt like rik funksjonalitet som PDCP-protokollen. I sin enkleste form ville den kunne styre protesen i on/off-modus. 


\section{PDCP and can}

Når protesen er ferdig skal den kunne styres gjennom PDCP-protokollen. PDCP-protokollen er en åpen kilde protese kommunikasjonsprotokoll. Den har blitt til ved UNB i Canada og har som ambisjon og bli den nye standarden for protesekommunikasjon. 

I dette prosjektet har det blitt brukt en NTNU produsert PDCP-implementasjon. Den var oppdelt i to lag, et høynivå\cite{bib:nordal} lag som implementerte selve funksjonaliteten til protokollen og et maskinvare abstraksjonslag\cite{bib:zamojski} som var kodet for å være lett å tilpasse til ny maskinvare. 

I masteroppgaven\cite{bib:zamojski} knyttet til koden hevdes det at koden skal være lett å tilpasse til en mikrokontroller med intern CAN-kontroller. Dette var ikke min erfaring. Det ble brukt mye tid på å forsøke og kode om maskinvarelaget til å passe med AT90CAN mikrokontrolleren. Etter å ha jobbet mye med koden er min konklusjon at den er godt egnet om man skal skifte AVR mikrokontroller, men fortsatt holde seg til den eksterne CAN kontrolleren MCP2515 som koden har blitt designet rundt. 

Da man ikke greide å tilpasse det eksisterende maskinvare abstraksjonslaget ble det skrevet et nytt et som implementerte basis funksjonaliteten som krevdes for å teste ut PDCP-protokollen. Denne koden finnes i hal-c filen. Bruken av den interne CAN-kontrolleren er gjort med et åpent CAN bibliteket skrevet for AT90CAN mikrokontrolleren. Biblioteket består av filene can.c og can.h.




\section{main}



-----------------

Det som i hovedsak manglet ved overtagelsen av prosjektet var å skrive ferdig programvare til NRWDen. Det var skrevet drivere til de fleste modulene hvor koden var av varierende kvalitet, skrevet mer for å teste maskinvaren enn for å kunne brukes i det ferdige produktet. 

Modulariseringen av koden ble beholdt da den allerede var delt opp i fornuftige deler. 

Systemet er for det meste drevet av interrupts, både interne og eksterne. Motorkommuteringen, posisjonsmålingen, motagelser av CAN-meldinger, fartsmåling og så videre skjer alle inni interruptrutiner. Når koden som kjører til en hver tid kan bli avbrutt av en interrupt rutine er det meget viktig å kode slik at det ikke oppstår race[?] kondisjoner. Den enkleste måten å forhindre dette på er å sørge for best mulig seperasjon mellom modulene, så ikke en modul kan endre på variabler brukt av en annen modul. 

Det nederste laget er driverne til de forskjellige hardware modulene, current.h for strømovervåkning, position.h for posisjonssensoren, motor.h for motorstyring og can.h for det nederste laget av PDCP protokollen.

Selve implementasjonen av PDCP protokollen er en porting av programvare skrevet av  Andreas Nordal og Andrzej Zamojski i sine masteroppgaver \cite{bib:nordal,bib:zamojski}. 


\chapter{Diskusjon}




\chapter{Konklusjon}

Hva har blitt diskutert i denne oppgaven

Hva har blitt gjort på dette prosjektet

Hva er det som er igjen for å fullføre prototypen





\begin{thebibliography}{99}
\bibitem{bib:zink}
  Arthur Zinck,
  \emph{Design of a compact, reconfigurable, prosthetic wrist}.
  2011.
  
  
\bibitem{bib:stavdahl2002}
	Øyvind Stavdahl
	\emph{Optimal wrist prosthesis kinematics: Three-dimensional rotation statistics and	parameter estimation.}
Department of Engineering Cybernetics, Norwegian University of Science and
Technology. 2002. PhD Thesis.  
  
\bibitem{bib:kraakenes}
  Andreas Kråkenes,
  \emph{Styresystem for kybernetisk håndleddsprotese}.
  Master i teknisk kybernetikk
  2011.
  
\bibitem{bib:nordal}
  Andreas Nordal,
  \emph{Implementasjon og testing av en åpen bussprotokoll for armproteser}.
  Master i teknisk kybernetikk
  2012.
  
\bibitem{bib:zamojski}
  Andrzej Zamojski,
  \emph{Design, Implementation and Testing of Low-level Layers of the PDCP for the AVR Platform}.
  Master i teknisk kybernetikk
  2012.
  
\bibitem{bib:brattbakken}
	Inge Brattbakken
	\emph{Embedded control system for cybernetic wrist prosthesis}
	Master of Science in Engineering Cybernetics
	2010.
	
\bibitem{bib:pdcp}
	Yves Losier
	\emph{Prosthetic Device Communication Protocol for the AIF UNB Hand Project}
	UNB Hand Project Systems Integrator
	2012.
	
\bibitem{bib:at90can}

	\emph{8-bit AVR Microcontroller with CAN controller AT90CAN128. Datablad.}
	Atmel
	
\bibitem{bib:bldc}
	
	\emph{Brushless DC-Servomotor, series 0620 B. Datablad}
	Faulhaber
	
	
	
\end{thebibliography}

\appendix

\chapter{Innhold CD}

\chapter{Funksjonsspesifikasjon NRWD}

\label{fig:funkspes}

\chapter{Diverse}


\begin{table}[h]
	\begin{center}
		\begin{tabular}{ | c | c |}
		\hline
			Duty cycle &  Vinkelhastighet \\ \hline
			80	& 156 grader/sekund\\ \hline
			65	& 94 grader/sekund\\ \hline
			50	& 44 grader/sekund\\ \hline
		\end{tabular}
	\end{center}
\caption{Vinkelhastighet til NRWDen ved ulike duty cycles, 12V spenningsforsyning}
\label{tab:velocity}
\end{table}





\end{document}