\documentclass[12pt,a4paper]{report}
%\usepackage[language]{babel}
\usepackage{listings}
\usepackage[norsk]{babel}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\author{Geir Turtum}
\title{Styresystem for kybernetisk håndledd}
\begin{document}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
 % frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
 % basicstyle=\footnotesize\ttfamily,
  %keywordstyle=\bfseries\color{green!40!black},
  %commentstyle=\itshape\color{purple!40!black},
  %identifierstyle=\color{blue},
  %stringstyle=\color{orange},
}

\lstset{language=C}

\maketitle


\chapter*{Oppgavetekst}

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/oppgavetekst}
\caption{}
\label{fig:oppgavetekst}
\end{figure}


Instituttet har sammen med University of New Brunswick, Canada, stått sentralt i utviklingen av et motorisert protesehåndledd med unike kinematiske egenskaper. Det foreligger et maskinvaredesing og en prototyp av styresystemet, og dette systemet skal nå ferdigstilles og programmeres slik at protesen kan brukes i forsknigssammenheng. Sentrale systemegenskaper inkluderer kommunikasjon over en CAN-buss ved hjelp av protokollen PDCP, noe signalbehandling og styring av en børsteløs DC-motor.
 
\begin{enumerate}
\item Gi en kort oversikt over prosjektets bakgrunn og nåværende status, der du legger vekt på systemets tilstand relativt dets spesifikasjoner og tiltenkte anvendelse.

\item Foreliggende HW-design er basert på en enkelt mikrokontroller som skal stå for både motorkommutering, regulering, signalbehandling og kommunikasjonsprotokoll(er). Foreta en vurdering av om dette designet er egnet, med spesiell vekt på avbruddshåndtering og sanntidsaspekter. Gjør om nødvendig praktiske målinger for å underbygge din konklusjon.
 
\item Foreslå på bakgrunn av punkt 2 en maskin- og programvarearkitektur for systemet. Eksisterende løsninger bør gjenbrukes i den grad det er mulig og hensiktsmessig.

\item Implementer og test systemet så langt tiden tillater det.

\end{enumerate}
 
 
\chapter*{Sammendrag}

Denne prosjektoppgaven tar for seg design og utvikling av styresystemet til håndleddsprotesen NRWD(NTNU Rotary Wrist Device). NRWD ble i sin tid skapt på bakgrunn av doktorgradsavhandingen\cite{bib:stavdahl2002} til Øyvind Stavdahl.

Det har blitt skrevet flere prosjekt- og masteroppgaver\cite{bib:brattbakken,bib:kraakenes} om NRWDen hvor alle har hatt som mål å realisere en prototype av protesen, men på grunn av ulike årsaker ikke har fullført. Denne oppgaven baserer seg i hovedsak på arbeidet til Andreas Kråkenes \cite{bib:kraakenes}. Han har produsert maskinvare lagt ut på flerlagskort, samt skrevet programvare for testing av maskinvaremodulene. Noe som la et meget godt grunnlag for videre arbeide. 

I denne prosjektoppgaven har styresystemet blitt ferdigstilt og det har blitt gjort anbefalinger til endringer i maskinvare der man har sett muligheter for forbedringer. 

Kommunikasjonen med protesen går over standard analoge og digitale elektroder og med den åpne protokollen PDCP(Prosthetic Device Communication Protocol). Implementeringen av protokollen er gjort av tidligere \mbox{NTNU} studenter\cite{bib:nordal,bib:zamojski} mens undertegnede har stått for integreringen av protokollen med protesens styresystem. 



\chapter*{Anerkjennelse}

Jeg vil takke min veileder, Øyvind Stavdahl. Som selv under vanskelige omstendigheter, tokk seg rikelig med tid til sine studenter. Jeg vil også takke mine foreldre som kom med verdifulle tilbakespill under skrivingen. 



\chapter*{Nomenklatur}

\begin{itemize}

\item NRWD - NTNU Rotary Wrist Device
\item PDCP - Prosthetic Device Communication Protocol
\item CAN - Controller Area Network
\item PWM - Pulse Width Modulation
\item UNB - University of New Brunswick
\item ISR - Interrupt Service Routine
\item LDO - Low Dropout Regulator
\item BLDC motor - Brushless DC electric motor


\end{itemize}



\tableofcontents


\chapter{Introduksjon}

\section{Bakgrunn for oppgaven}

Ideen bak protesen kommer fra Øyvind Stavdahls doktorgradsavhandling \cite{bib:stavdahl2002} fra 2002. I den viste eksperimenter med friske håndledd at en vinkel mellom lengdeaksen til underarm og rotasjonsaksen til håndleddet gjorde flere bevegelser enklere for brukeren å utføre. 

For å teste disse resultatene i praksis trenger man en 1-akse håndleddsprotese med design som muliggjør valgfri rotasjonsaske, se figur \ref{fig:wrist_angel}. Dette ble bygget som en del av mastergraden til Arthur Zink\cite{bib:zink} ved University of New Brunswick, Canada. Etter at mekanikken var ferdigstilt trengte man et styresystem for å styre protesen. 
 
\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/wrist_angel}
\caption{Vinkel mellom håndprotese og underarm kan varieres. Kilde: Styresystem for kybernetisk håndleddsprotese\cite{bib:kraakenes}}

\label{fig:wrist_angel}
\end{figure}

Det ble også funnet ut at dette var en god anledning til å teste ut den åpne protesestyringsprotokollen PDCP, som da var under utvikling hos UNB. Som krav i funksjonsspesifikasjonen til NRWDen ble det satt at den skulle kommunisere ved hjelp av denne protokollen. I tillegg skulle den kunne styres med de mer konvensjonelle analoge og digitale elektrodene. 


\section{Tidligere arbeid}

Realisering av styresystemet til protesen har hittil vært påbegynt i to mastergradoppgaver. Den siste av disse var skrevet av Andreas Kråkenes i 2011\cite{bib:kraakenes} som kom langt på vei til å fullføre designet. Hovedgrunnen til at protesen enda ikke har blitt fullført skyldes at det første designet innholdt en alvorlig \mbox{arkitekturfeil} som hindret kommunikasjonen mellom de to mikrokontrollerene som skulle styre protesen. Det ble brukt mye tid på å ordne opp i problemet. Det endte med at man gikk man over til en løsning hvor en mikrokontroller skulle styre hele systemet. 

Da prosjektet ble overtatt av undertegnede, var alt av hardware designet og lagt ut på prototypekort. Programvare for å teste deler av systemet var ferdigskrevet, men koden var av varierene kvalitet og mye funksjonalitet var ikke implementert. Flest mangler var knyttet til de ulike regulatorene og implementasjonen av PDCP-protokollen. 

To mastergradsstudenter ved NTNU\cite{bib:nordal,bib:zamojski} laget i 2012 en implementasjon av PDCP-protokollen. UNB hadde tildigere laget en implementasjon basert på PIC mikrokontrolleren, mens denne var designet for ATMELs AVR mikrokontrollere. Implementasjonen var designet for at det skulle være enkelt å overføre koden til ny maskinvare, noe som gjorde at den egnet seg godt for dette prosjektet.


\section{Mine bidrag}

Prosjektet ble startet med gå gjennom den overleverte maskinvaren og medfølgende driverkode modul for modul. Detaljer rundt hvordan de ulike modulene ble testet er beskrevet i kapittel \ref{chap:modTesting}.

Den overleverte koden var av varierende kvalitet. Koden var strukturert på et fornuftig vis, med en c-fil for hver maskinvare modul. Denne strukturen ble beholdt ut prosjektet. Selve driverkoden trengte en del mer arbeid. Det var skrevet nok til å teste basisfunksjonaliteten til hver modul, men måtte utvides med tilleggsfunksjonalitet før den kunne brukes i prosjektet. 

Under testing av maskinvaren ble det funnet muligheter for forbedringer i spenningsregulator og posisjonssensormodulene. Kapittel \ref{chap:modTesting} oppsumerer anbefalte endringer i maskinvaren.


Det første styressystemet som ble designet til NRWDen benyttet seg av to mikrokontrollere for å håndtere alle oppgavene. Denne arkitekturen gikk man bort fra da man fikk problemer med kommunikasjonen mellom de to kontrollerne og man gikk over til å bruke en mikrokontroller. Som en del av oppgaven ble det gjort grundige undersøkelser om den valgte mikrokontrolleren hadde nok ressurser til å styre systemet på egen hånd. Diskusjonen rundt dette er gjort i kapittel \ref{chap:interrupt}.

Ifølge funksjonsspesifikasjonene skal protesen ha minst tre forskjellige styringsmoduser, maksimum fart i valgt retning, posisjons- og hastighetsstyring. Koden til de forskjellige regulatorene ble alle skrevet fra bunnen av. For detaljer om hvordan de ulike regulatorene ble implementert, se kapittel \ref{chap:sw}.

På slutten av prosjektet ble styringssystemet integrert med kommunikasjonsprotokollen PDCP. Implementasjonen av protokollen var allerede gjort, jobben besto av å skrive om maskinvare abstraksjonslaget. Hvorfor og hvordan dette ble gjort, er beskrevet i kapittel \ref{chap:sw}.

\section{Utviklingsmetodikk og fremgangsmåte}

Dette prosjektet består av et maskin- og programvare system som allerede da det ble overtatt var delt opp i klare moduler. Dette ble utnyttet i planleggingsfasen. Som nevnt tidligere var det meste av maskinvare designet ferdig, mens den gjensto å ferdigstille programvaren. Det var også mye programvare som var skrevet av tidligere studenter som skulle flettes inn i prosjektet for ikke å reprodusere arbeide som var gjort tidligere. Det tenkes spesielt på lavnivå implementasjonen av PDCP protokollen som ble utviklet av  Andrzej Zamojski \cite{bib:zamojski} og  Andreas Nordal\cite{bib:nordal} samt programvare driverne til NRWDen skrevet av Andreas Kråkenes. 

Metoden min sin hovedlinje var i størst grad arbeide på prosjektet modul for modul, forsikre meg om at alt fungerte atskilt, for til slutt å sette modulene sammen til et komplett styresystem. Hvordan hver modul ble testet blir gått gjennom i kapittel \ref{chap:modTesting}. Kort oppsummert var planen:

\begin{itemize}

\item Sette seg inn i bakgrunnsstoff for oppgaven.
\item Test hver maskinvare modul for seg, samt tilhørende programvare driver.
\item Sjekk om maskinvare og programvare oppfyller kravene satt av funksjonsspesifikasjonen.
\item Fullfør driverkoden til modulen som blir testet. 
\item Sett seg inn i implementasjonen av PDCP gjort av tidligere NTNU studenter. 
\item Integrere PDCP med styringssystemet.
\end{itemize}


Verktøyet som ble brukt for å budsjettere tiden og sørge for at man kom i mål med prosjektet til rigktig tid var, på anbefaling fra veileder, Gantt diagrammet. Figur \ref{fig:fig_gantt_diagram} viser framgangsplanen for de første ukene av prosjektet og hvorvidt planen ble overholdt. Gantt diagrammet var et nyttig verktøy å bruke, ikke bare ga det en klar oversikt over hvilke oppgaver man hadde igjen, men også hvorvidt man greide å overholde de tidsfrister man hadde satt. 


\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/fig_gantt_diagram}
\caption{Gantt diagram}
\label{fig:fig_gantt_diagram}
\end{figure}


Utviklingen av programvare ble gjort på en windows maskin med Atmel Studio 6. For versjonskontroll av kode og dokumenter falt valget på Git.

\section{Rapportens oppbygning}

Skrive om hva som kommer når?

I kapittel \ref{chap:spesifikasjoner} blir spesifikasjonene til systemet gått igjennom. Dette kapittelet vil ofte bli referert til når man diskuterer maskin- og programvare som oppfyller deler av funklsjonskravet. 



\chapter{NRWD Spesifikasjoner}

Dette kapittelet går gjennom funksjonsspesifikasjonene til NRWDen punkt for punkt. Spesifikasjonene beskriver kravene til systemet i sin hellhet fra de fysiske dimensjonene, kommunikasjonsgrensesnittet opp mot protesen til oppløsningen på de ulike sensorene og maksimum vinkelhastighet til protesen. 

Delkapittlene som følger tar for seg hver sin del av funksjonsspesifikasjonene. De beskriver hvike av kravene som er oppfylt, de som enda ikke er implementert og de som krever mer arbeid. Kapittelet beskriver systemet i sin nåværende tilstand og er ment for å hjelpe neste person som skal arbeide på prosjektet til å få en rask oversikt over hva som er gjort og hva som må gjøres. På noen av funksjonskravene vil statusen være kommentert som "Ikke relevant", dette gjelder de spesifikasjonene som omhandler de rent mekaniske sidene av systemet.

Ikke inkludert i kapittelet er de overordente funksjonsspesifikasjonene til NRWDen. Disse kan leses i det originale spesifikasjonsdokumentet vedlagt denne oppgaven, se vedlegg \ref{fig:funkspes}.

\section{Wrist Joint Function, WJF}

Beskriver det roterende leddet i protesen og hvordan festeanordningen til underarm og eventuell håndleddsprotese skal være manuelt justerbar. 

\begin{center}

	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} |}
	
	\hline
	Nr & Beskrivelse  & Status \\ \hline
	WJF-01 & The NRWD joint shall be a single, simple revolute joint which axis of rotation can be placed at an attitude with respect to the forearm and terminal device as spedcified in [1], Equations (7.4) and (7.5).  & Ikke relevant \\ \hline
	WJF-02 & The joint axis should be manually adjustable to other attitudes than that specified in WJF-01. & Ikke relevant \\ \hline
	WJF-03 & The joint shall enable an angular excursion of at least 180 degrees. The excursion should be unlimited. & Ikke relevant \\ 
	\hline
	 
	\end{tabular} 
\end{center}

\section{Wrist Motor Function, WMF}

WMF delen av funksjonsspesifikasjonen beskriver kravene til protesens vinkelhastighet og moment. Viktig å merke seg at det her settes krav til at motoren skal være beskyttet mot overopphetning i maskinvare.

\begin{center}
	\begin{tabular}{ | p{2cm} | p{8cm} | p{4cm} |}
	\hline

Nr & Beskrivelse & Status  \\ \hline
WMF-01 & The wrist joint (output of the gear train) shall have a maximum angular velocity of at least  1.4 rad/s (81 deg/s). The maximum velocity should be as high as possible. & Høyeste målte vinkelhastighet er målt til 2.72 rad/s (156 grader/sekund) \\ \hline
WMF-02 & The wrist joint should have a maximum torque of at least 34,3 mNm. & Ikke målt, men ifølge målinger gjort av Zink \cite{bib:zink} er stall torque på 59.6 mNm.  \\ \hline
WMF-03 & The motor shall have a maximum mechanical output power of at least TBC W. & NA  \\ \hline
WMF-04 & The motor shall be protected from overheating. The protection should be implemented by hardware. & Dette har blitt implementert i strømovervåkings modulen. \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Wrist Servo Function, WSF}

WDF delen av funksjonsspesifikasjonen beskriver kravet til posisjonssensoren og hvilke regulatorer som systemet skal implementere. 

\begin{center}
	\begin{tabular}{ | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status  \\ \hline
WSF-01 & The movements of the wrist joint shall be controllable according to the follwing modes:
\begin{itemize}
\item On/Off-mode
\item Position mode
\item Velocity mode
\end{itemize}
 & Alle kontrollerne er Implementert i controller.c  \\ \hline
WSF-01-01 & In On/Off-mode the motor shall be at rest or run at maximum speed (open-loop) in one  direction according to a given setpoint.  & Implementert ved bruk av PI-kontroller som kjører motoren nærmest mulig maksimum tillatte strømforbruk.  \\ \hline
WSF-01-02 & In position mode the joint angle shall be proportional  to a given angular setpoint.  & Implementert med PI-kontroller. \\ \hline
WSF-01-02-01 & The WSF shall include an absolute position sensor. This sensor shall provide no less than 10 bits resolution per revolution. & En 12-bits magnetisk enkoder er brukt.  \\ \hline
WSF-01-03 & In velocity mode the joint angular velocity shall be crudely proportional to a given velocity setpoint. & Implementert med PI-kontroller. \\ \hline
WSF-01-03-01 & The WSF shall include a velocity sensor or estimator. & Hastighet er estimert ved hjelp av hall elementene. \\ \hline
WSF-02 & The movements of the wrist joint should be controllable according to the follwing modes:  
\begin{itemize}

\item Torque mode
\item Impedance mode
\end{itemize}
 & Ikke implementert.  \\ \hline
WSF-02-04 & In torque mode the motor torque shall be proportional to a given torque setpoint.  & Ikke implementert.  \\ \hline
WSF-02-04-01  & The WSF should include means for monitoring motor current.  & Implementert, se strømovervåknings modulen.  \\ \hline
WSF-02-05 & In impedance mode the mechanical impedance of the joint shall be determined by a given impedance setpoint  & Ikke implementert.  \\ \hline
WSF-03 & WSF shall provide an interface to WCF through which the modes (described in WFS-01 to WSF-02) can be selected and relevant parameters can be set, and through which WSF can report relevant state variables TBD. & Koden er lagt opp for at dette enkelt kan bli implementert når kommunikasjons spesifikasjonen er klargjort.  \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Wrist Communication Function, WCF}

WCF delen av funksjonsspesifikasjonen beskriver hva slags kommunikasjonsgrensesnitt systemt skal implementere. 

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status \\ \hline
WCF-01 & The NRWD shall have a two-wire Proximal Communication Interface (PCI) and a two-wire Distal Communication Interface (DCI). & Implementert ved CAN-bus. \\ \hline 
WCF-02 & The PCI shall be configurable so that it implements two (0V, 7,2V) analog input lines or a bidirectional twowire CAN interface with the PDCP protocol(Losier,2009). & Implementert ved CAN-bus og PDCP-protokollen. \\ \hline
WCF-02-01 & The analog input lines shall be able to sample both lines at a rate of 1 kHz. The sampling rate should be as high as 2 kHz. & Implementert i analog.c \\ \hline
WCF-03 & The DCI shall be configurable so that it implements two (0 V, 7.2 V) analog output lines or a bidirec[1]onal two-wire CAN interface with the PDCP-protocol.  & Implementert ved CAN-bus og PDCP-protokollen. Implementasjonen av PDCP-protokollen er ikke ferdig.  \\ \hline
WCF-04 & The WCF shall be configurable to an all-Analog mode, with the PCI as an analog input interface and the DCI as an analog output interface. & Analog output interface ikke implementert i verken HW eller SW.  \\ \hline
WCF-05 & The WCF shall be configurable to an all-digital mode, with the PCI and the DCI acting as bidirectional CAN bus interfaces. & Implementert. CAN buss trenger bare et tilkoplingspunkt.  \\ \hline
WCF-07 & The WCF should be configurable to a hybrid mode in which the PCI acts as two analog input lines while DCI acts as a bidirectional CAN interface (cf. WCF-01) & Ikke implementert i HW.  \\ \hline
WCF-10 & The WCF shall include a serial interface for downloading software and for debugging/diagnostic purposes. & Implementert ved bruk av JTAG.  \\ \hline
WCF-11 & WCF shall implement an interface to WSF according to WSF-03. &  Se WSF-03. \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Wrist Power Function, WPF}

WPF delen av funksjonsspesifikasjonen beskriver kraftforsyningen til systemet.

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status \\ \hline
WPF-01  & The WPF shall accept external power in the form of an unregulated two-wire DC supply. & Implementert ved brukt av intern spenningsregulator. \\ \hline
WPF-02 & The NRWD shall tolerate and run normally when powered with a voltage in the range (6 V, 12 V). The range of usable voltages should be as wide as (5 V, 18 V). &  Valgte spenningsregulator opererer normalt innenfor området (7V, 18V). Det er anbefalt å gå over til en Low Droupout Regulator for å tilfredstille kravet.  \\ \hline
WPF-03 & The NRWD shall tolerate supply voltage in the range (0 V, 12 V) without exhibiting unpredictable behaviour and without getting damaged. & Implementert ved bruk av brown out deteksjon internt på AVRen. [todo] \\ \hline
WPF-04 & The NRWD should automatically limit its motor current to a level that does not reduce the supply voltage below the interval given in WPF-01. & Ikke implementert.  \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Proximal Attachment Function, PAF}

PAF delen av funksjonsspesifikasjonen beskriver festeanordningen og grensesnittet mellom NRWDen og underarmen. 

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline

Nr & Beskrivelse & Status\\ \hline
PAF-01 & The PAF shall comprise two parts, the proximal of which is adapted to be permanently attached to the forearm socket and the distal permanently attached to the wrist unit. The parts must ?mate? to form a mechanically stable connection while also being detachable. & Ikke relevant\\ \hline
PAF-01-01 & The proximal part of the PAF shall be hollow to allow access to the space within the socket proximally to the wrist. & Ikke relevant\\ \hline
PAF-02 & PAF disconnection should be possible with hand or a simple tool, e.g. a screwdriver. &  Ikke relevant\\ \hline
PAF-03 & The PAF shall include a four-wire electric coupling, preferably mechanically integrated with the PAF itself. & Ikke implementert i prototype hardwaren. \\ \hline
PAF-03-01 & The PAF electrical coupling shall include at least two power supply wires/contacts capable of transferring a constant current of 4 A per wire. & Ikke implementert i prototype hardwaren. \\ 

	\hline
	\end{tabular} 
\end{center}

\section{Distal Attachment Function, DAF}

DAF delen av funksjonsspesifikasjonen beskriver festeanordningen og grensesnittet mellom NRWDen og en eventuell håndprotese. 

\begin{center}
	\begin{tabular}{  | p{2cm} | p{8cm} | p{4cm} | }
	\hline
Nr & Beskrivelse & Status\\ \hline
DAF-01 & The DAF should comprise two parts, the proximal of which is permanently attached to the wrist and the distal permanently attached to the terminal device. The parts must mate to form a mechanically stable connection while also being detachable. &  Ikke relevant\\ \hline
DAF-02 & The DAF shall include a four-wire electric coupling, preferably mechanically integrated with the DAF itself. & Ikke implementert i prototype maskinvaren. \\ \hline
DAF-02-01 & The DAF electrical coupling shall include at least two wires/contacts capable of transferring a constant current of 2 A per wire, and these wires shall be connected to the power supply wires from PAF. & Ikke implementert i prototype maskinvaren. \\ \hline
DAF-02-02 & The DAF electrical coupling should be rotatable without twisting the wires. & Ikke implementert i prototype maskinvaren. \\ 
	\hline
	\end{tabular} 
\end{center}

\chapter{Mekanikken}

Mekanikken i protesen er et resultat av en masteroppgave skrevet ved universitetet i  New Brunswick, Canada. Mekanikken består av to seksjoner, den proksimale og distale (henholdsvis seksjonen nærmest underarmen og den lengst unna). De to seksjonene kan rotere fritt mot hverandre ved hjelp av et kulelager. Selve bevegelsen er drevet av en børsteløs DC-motor som er koplet til et gir tog med utveksling 333:1, se seksjon \ref{sec:motordriver}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/mekanikk}
\caption{Oversiktbilde over den indre mekanikken til protesen. Figur hentet fra \cite{bib:zink} }
\label{fig:mekanikk}
\end{figure}


Under testing av motordriveren ble det funnet at det, ved en forsyningsspenning på 12V, måtte til en dutycycle på 60\% for å bevege mekanikken. Ved rundt 80\% dutycycle ble strømmen til motoren kuttet av strømovervåkingsmodulen, da strømmen gjennom motoren oversteg maksimum grensen. Denne grensen er satt i maskinvare for å unngå at motoren blir ødelagt på grunn av overopphetning. Dette ga regulatoren et veldig lite rom å jobbe innenfor, noe som gjorde implementasjonen av posisjon og hastighetskontrolleren meget vanskelig. 

Mekanikken ble tatt med til mekaniske verksted ved NTNU for å se om de kunne løse problemet. Det viste seg at aksen til det minste tannhjulet var bøyd, noe som førte til ekstra friksjon i systemet. Tannhjulet det er snakk om er det som er koblet til Faulhaber girboksen i den distale seksjonen, se figur \ref{fig:mekanikk}. Verkstedet fikk bøyd det til slik at det gikk fra å ha en kast på 0.22 mm til 0.03 mm. Dette reduserte friksjonen betraktelig og mekanikken kunne nå beveges med en dutycycle ned mot 40\%. 

Da mekanikken ble undersøkt ble det også funnet at kulelageret i protesen begynte å bli slitt noe som førte til yterligere friksjon i systemet.

Om rettingen av giraksen løser problemet på langt sikt er usikkert. At problemet har oppstått tyder på at mekanikken ikke er riktig dimensjonert for de krefter den kan bli utsatt for. En teori på hvordan problemet kan ha oppstått, er at man har vridd på den distale seksjonen, noe som påfører store krefter på den indre mekanikken. Dette tyder på at mekanikken kan ha behov for en ny revisjon før den er robust nok til å kunne brukes i eksprimenter.

For fremtidig bruk er det lagt ved en oversikt over rotasjonshastigheten til protesen ved forskjellige dutycycler, se vedlegg \ref{tab:velocity}. Målingene er gjort etter at mekanikken var rettet av verkstedet. Denne kan brukes for å se om problemet har gjenoppstått.


\chapter{Interrupt diskusjon}
\label{chap:interrupt}

%Hvorfor diskutere interrupt

%Problemer med gamle arkitektur

\section{Bakgrunn}

Tidligere forsøk på å realisere styresystemet til NRWDen har brukt to mikrokontrollere. Den ene skulle brukes til motor kommuteringen, mens den andre skulle håndtere alt annet som regulering og kommunikasjon. Da systemet ble testet oppsto det problemer med kommunikasjonen mellom mikrokontrollerene. Selv etter mye testing fant man aldri løsningen til problemet. Dette førte til at man gikk over til en arkitektur som brukte en enkelt mikrokontroller.

%Ny arkitektur

Spørsmålet var da om den valgte mikrokontrolleren, AT90CAN128 kjørende på 16 MHz, var nok til å håndtere alle oppgaver som før hadde blitt fordelt på to mikrokontrollere. Dette kapitlet tar for seg denne problemstillingen. 

\section{Et interrupt drevet system}

%Hva slags system er dette her? Soft real time? 

%Forklar hvordan systemet er bygget på interrupts



Så hva slags type system er det som styrer protesen? Styringssystemet er nesten utelukkende interrupt drevet. Bortsett fra regulatoren som blir kjørt inni main while løkken er resten styrt med interrupts. Motorkommuteringen, kommunikasjonsprotokollen, fartsestimeringen, posisjonsavlesningen og strømovervåkingen blir alle styrt gjennom interrupts. Hver av disse oppgavene krever at tiden mellom et interrupt blir generert og mikrokontrolleren går inn i tilhørende ISR(Interrupt Service Routine) ikke overstiger en viss lengde. 

Om et interrupt ikke blir håndtert innenfor tidsfristen en eller flere ganger, vil systemet i beste fall bli mindre nøyaktig, i verste fall vil det slutte å fungere. Som et eksempel kan man ta for seg posisjonssensoren. Posisjonen er proporsjonal med dutycycelen til sensorsignalet. Denne leses av ved å måle tiden mellom positiv og negativ flanke på signalet. Hver endring i nivå hos signalet genererer et interrupt, se figur \ref{fig:posisjon_min_periode}. Hvis tiden det tar for mikrokontrolleren å behandle interruptet tar lengere tid enn forventet vil posisjonen bli feil avlest. Man må kunne gi en garanti for at mikrokontrolleren har nok ressurser til å håndtere alle interruptene som blir generert. Ellers vil man risikere at man får et system som virker tregt og uresponsivt eller slutter å virke. Systemet har derfor blitt analysert for hvor mye tid man bruker inni ISRene.


%Hvorfor er det viktig at alle interrupts blir håndtert

%Hvordan håndterer AVR interrupts

%KOrt om hvilke interrupt systemet må håndtere


Typen interrupts som systemet skal håndtere kan deles inn i to typer, periodiske og aperiodiske. 

De periodiske er som følger:
\begin{itemize}
\item HALL\_X\_vect - Genereres hver gang en av de tre hall sensorene i motoren skifter nivå
\item TIMER3\_CAPT\_vect - Genereres på hver flanke til PWM signalet fra posisjons sensoren
\item TIMER0\_OVF\_vect - Brukes til å beregne hastigheten til motoren
\end{itemize}


De aperiodiske er:
\begin{itemize}
\item CANIT\_vect - Genereres hver gang det kommer en CAN melding
\item CURRENT\_vect - Genereres når maskinvaren slår av strømmen til motoren
\item RESET 
\end{itemize}


For å analysere systemet ble varigheten til hver interrupt målt. Et interrupt i mikrokontrolleren består av tre deler. Det er kontektsskiftet hvor mikrokontrolleren lagrer unna stacken før man går inn i ISRen, arbeidet som blir utført inni rutinen og gjennopprettingen av stacken i det man forlater den. Tiden det tar for mikrokontrolleren å utføre de to konteksskiftene er et fast antall instruksjoner. Det faktiske tallet finnes i mikrokontrollerens datablad \cite{bib:at90can}. Varigheten til hvert interrupt ble målt ved å sette en GPIO-pinne høy ved inngangen av interruptet og lav i det den gikk ut. Hvor lenge utgangen til GPIO-pinnen var høy ble målt med et oscilloskop. Se tabell \ref{tab:interrupt} for oppsumering av tidsbruk til de periodisk interruptene.

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{ | l | l | l | l |}
		\hline
	Navn & Varighet ($\mu$s) & Maks frekvens & Tidsbruk per sekund($\mu$s) \\ \hline
	HALL\_X\_vect  & 4.5 & 3600 & 16200  \\ \hline
	TIMER3\_CAPT\_vect  & 4.8 & 490 & 2352 \\ \hline
	TIMER0\_OVF\_vect  & 3.2 & 61 & 196 \\ \hline
	Totalt &  &  & 18742  \\
		\hline
		\end{tabular} 
	\end{center}
	\caption{Viser varigheten til hvert interrupt, hvor mange ganger de blir kjørt i sekundet og totalt tidsbruk per sekund. }
	\label{tab:interrupt}
\end{table}

Vi ser av tabell \ref{tab:interrupt} at mikrokontrolleren bruker mindre enn 2\% av tiden inne i en interrupt rutine. Det gir rikelig med tid til å håndtere kontrolloopen som kjører utenfor interruptene. Derimot så garanterer det ikke at alle interrupts vil bli håndtert innenfor rimelig tid. I et tilfelle hvor en eller flere av modulene genererer et interrupt samtidig, kan dette føre til midlertidige feil i systemet. Siden dette ikke er et hardt sanntidssystem, hvor overskridelsen av en tidsfrist hadde gjort systemet ubrukelig, er disse potensielle midlertidige feilene akseptable. 

Et annet punkt er virkemåten til ISRene i dette systemet. Resultatet til en ISR er ikke avhengig av resultatet fra forrige gang den kjørte. Hvilket betyr at om en ISR gir ut feil resultat, vil dette være ordnet neste gang den kjører. Underforstått at det bare var en sporadisk forsinkelse som førte til feilen og ikke en større feil ved systemet. Da ISRene opptar under 2\% av prosessortiden og de alle operere ved ulike frekvenser, vil kollisjon mellom to eller flere ISR være et sjeldent fenomen. 

Det ble også undersøkt om mikrokontrolleren er rask nok til å håndtere kommuteringen av motoren. En den for treig vil den ikke kunne kommutere raskt nok til at motoren oppnår den ønskede hastighet. ATMELs applikasjonsnote AVR452 som tar for seg motor styring av børste løse DC motorer ved bruk av AT90CAN mikrokontrolleren. Den setter en teoretisk grense ved 3'478'000 rpm ved 8 MHz, da maksfarten til NRWD motoren er satt til 3600 rpm og mikrokontrolleren kjører på 16 MHz befinner vi oss godt innenfor kravene. 




\chapter{Maskinvaretesting og diskusjon}
\label{chap:modTesting}

%[TODO]  Dessverre var skjemategningen bare tilgjengelig i pdf format så utlegg må gjøres på nytt når kretsen skal miniatyriseres for å få plass inni protesen.


Dette kapittelet går gjennom maskinvaren som dette prosjektet har basert seg på. Det blir forklart hvordan hver modul har blitt testet og eventuelle forslag til forbedringer blir gitt. 

Dette prosjektet startet ikke fra grunnen av, men bygger videre på arbeidet til flere studenter. Således var det mye dokumentasjon, maskinvare og programvare som måtte gjennomgåes før det kunne bygges videre på. Det tenkes her spesielt på arbeidet til Andreas Kråkenes som var siste student som arbeided på NRWDen. Han som sto for utlegg og produksjon av maskinvareprototypen, se figur \ref{fig:nrwd_prototype}, som har blitt brukt under dette prosjektet. 

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/nrwd_prototype}
\caption{Prototypen av NRWD maskinvaren produsert av Andreas Kråkenes, her vist tilkoplet protesemekanikken.}
\label{fig:nrwd_prototype}
\end{figure}

Alt av overlevert maskin- og programvare ble gjennomgått og testet modul for modul for å se om det fungerte i henhold til det som sto i Kråkenes' oppgave \cite{bib:kraakenes}. Før arbeidet startet ble en kort testplan for hver modul utarbeidet. Den ble laget slik at da alt i planen var testet, skulle man være sikker på at maskin- og programvaren for valgt modulen oppførte seg som forventet. Under følger resultatene av testingen, samt en diskusjon rundt hver modul. For flere detaljer rundt maskinvaren og skjemategninger, se Kråkenes' oppgave\cite{bib:kraakenes}. 

\section{Mikrokontroller}

Styringen av protesen er gjort med en ATMEL AT90CAN128 AVR mikrokontroller. Opplasting av programvare og debugging ble gjort over JTAG via ATMELs programmerinsverktøy, JTAGICE 3. Det ble opprettet kontakt med AVRen og alt fungerte som forventet. 

\section{Spenningsregulator}

Ifølge funksjonskravet WPF-02 skal NRWDen operere normalt når den blir drevet av en spenningsforsynning mellom 6 og 12V. Spesifikasjonene sier ikke noe om hvilke spenninger som skal brukes internt, men den valgte mikrokontrolleren trenger 4.5V for å kjøre på 16MHz. Det har derfor blitt valgt at den eksterne spenningen skal reguleres ned til 5V.  

Spenningsregulatoren brukt i NRWDen er en linær regulator som i henhold til databladet gir ut 5$\pm$0.2V ved inngangsspenninger 7-20V. Det er viktig at NRWDen kan operere på spenninger ned til 6V da de vanligste batteriene som er brukt i slike proteser gir ut en spenning som kan gå ned til 6V. Da differansen mellom inngangs- og utgangsspenning kan være så lav som 1V, anbefales det å gå over til å bruke en LDO (Low Dropout Regulator). En LDO er spesielt designet for å operere under slike forhold. Et eksempel på en LDO som kan brukes er LF50CDT fra STMicroelectronics.  



\section{Posisjonsmåling}



Ifølge funksjonskravet WSF-01-02-01 skal NRWDen være utstyrt med en absolutt posisjonssensor med en oppløsning på minst 10 bit. 

Den nåværende løsningen er en magnetisk enkoder. Den leser av magnetfeltet til en magnet festet på den distale delen av NRWDen. Sensoren gir ut et PWM signal hvis dutycycle er proporsjonalt med vinkelen til magnetfeltet på sensoren, se figur \ref{fig:posisjon_hel_periode}.  Hver flanke på PWM-signalet generer et interrupt og tiden mellom en stigende og synkende flanke blir målt av mikrokontrolleren. 

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/posisjon_hel_periode}
\caption{Utgangen til posisjonssensoren målt med oscilloskop}
\label{fig:posisjon_hel_periode}
\end{figure}

Problemet med dette oppsettet kommer ved vinkler nær 0 og 360 grader. Ved disse vinklene vil tiden mellom to flankeendringer være under 1 $\mu$s, se figur \ref{fig:posisjon_min_periode}. Som beskrevet i kapittel \ref{chap:interrupt} bruker mikrokontrolleren 4.8 $\mu$s å behandle interruptet fra posisjonssensoren. Dette vil si at det andre interruptet som kommer enten ikke vil bli behandlet, eller bli behandlet for sent, noe som vil gi feil avlest vinkel. 

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{../Figurer/posisjon_min_periode}
\caption{Utgangen til posisjonssensoren ved lavest dutycycle}
\label{fig:posisjon_min_periode}
\end{figure}

Foreløpig er problemet løst i programvaren, men en bedre løsning ville vært å gjøre det i maskinvaren. En god løsning ville vært å lavpassfiltrere PWM-signalet for så å lese av vinkelen med en ADC. Dette løser ikke bare problemet med feil avlesning av vinkel nør 0 og 360 grader, men det vil også redusere antall interrupts som mikrokontrolleren må behandle. PWM-signalet har en frekvens på 245 Hz, noe som gir 490 interrupts i sekundet. Ved bruk av et lavpassfilter og en ADC vil man bare trenge å kalkulere posisjonen hver gang posisjonsregulatoren skal kjøre. GPIO pinnene på mikrokontrolleren har allerede mulighet for å aktivere en intern pullup motstand. Dette betyr at den eneste eksterne komponenten som kreves for å lage et lavpassfilter er en kondensator med passende verdi.

\section{Motordriver}
\label{sec:motordriver}

Protesens bevegelse er drevet av en børsteløs DC-motor med innebydge Hall-sensorer. Ved å lese av Hall sensorene vet man posisjonen til motoraksen og kan utifra det vite hvilket pådragsmønster man skal gi motoren får å få den til å rotere. Utgangen til Hall-sensorene er digitale og er koplet opp mot hver sin interrupt linje. Det blir da generert et interrupt hver gang utgangen skifter nivå. 

Ifølge funksjonskravet WMF-01 skal protesen minst ha en maksimums omdreiningshastighet på 81 grader/sek. Ifølge Zink\cite{bib:zink} er motoren giret ned med et forhold 800:1, se tabell \ref{tab:drive_train}. Dette stemmmer ikke med protesen brukt i dette prosjektet, da diameterene til drivhjulene fra motor til Faulhaber planetary gear ikke er som spesifisert hos Zink. Faktiske målinger viser at girforholdet til protesen er på 333:1. 

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/drive_train}
\caption{Tabellen viser girtoget til motoren slik det originalt var ment. Dette stemmer IKKE med den mekanikken brukt i dette prosjektet. Tabell hentet fra Zink, Design of a compact, reconfigurable, prosthetic wrist\cite{bib:zink}.}
\label{tab:drive_train}
\end{figure}

For å oppnå ønsket vinkelhastighet tilsvarer dette en motorhastighet på 4496 rpm, se formel \ref{eq:motor_rpm}. Ifølge motordatabladet \cite{bib:bldc} er makshastigheten til motoren 35600 rpm noe som faller godt innenfor kravet. 

\begin{equation}
 \frac{81 \text{grader/sekund} }{360 \text { grader}}  \times 333 \times 60 \text{ sekund} = 4495.5 \text{ rpm}
	\label{eq:motor_rpm}
\end{equation}

Da motorens hall sensorer genererer 6 interrupt per omdreining vil mikrokontrolleren måtte kunne håndtere minst opptil 3560 interrupts i sekundet, se formell \ref{eq:interrupt}. 

\begin{equation}
 \frac{35600 \text{ rotasjon/min}}{60 \text { sek/min}}  \times 6 \text{ interrupts/sek} = 3560 \text{ interrupts/sek} 
	\label{eq:interrupt}
\end{equation}

En testbenk ble satt opp for å teste om mikrokontrolleren greide å håndtere alle motor sensor interruptene. Et Arduino-brett ble brukt for å simulere utgangene til motorens Hall-sensorer med en hastighet som tilsvarte 400'000 rpm. Arduino-brettet var programmert til å påføre et bestemt antall interrupts som mikrokontrolleren telte. Under testing var antallet registrerte interrupts hos mikrokontrolleren likt antallet sendt ut fra Arduino-brettet. Da mikrokontrolleren fungerte feilfritt ved disse hastighetene kunne man være sikker på at mikrokontrolleren ville greie å håndtere kommuteringen av motoren ved de faktiske hastighetene. 


\section{Strømovervåkning}

Ifølge funksjonskravene WMF-04 og WSF-02-04-01 skal motoren være beskyttet mot overopphetning i maskinvare og man skal kunne måle hvor mye strøm motoren trekker. Overopphetning skjer når motoren trekker for mye strøm. Utregningen av den maksimalt tillatte strømmen er gjort tidligere av Kråkens\cite{bib:kraakenes} itifra motorens datablad\cite{bib:bldc} og er satt til 145 mA. 

\begin{figure}[h]
\centering
\includegraphics[width=0.9\linewidth]{../Figurer/fig_strommaaling}
\caption{Skjemategning til strømovervåknings modulen. Figur hentet fra Kråkenes\cite{bib:kraakenes}}
\label{fig:fig_strommaaling}
\end{figure}


Motoren får strøm gjennom et 20 KHz PWM-signal som går gjennom den 1 ohms store målemotstanden før det går til jord. Spenningen over målemotstanden blir lavpasfiltrert og forsterket av en operasjonsforsterker. Deretter går signalet inn på en komparator krets som setter en SR-vippe. Vippen sørger for å slå av strømforsyningen til motoren når den trekker mer enn den maksimalt tillatte strømmen. SR-vippen kan bli resatt av mikrokontrolleren. Utgangen til operasjonsforsterkeren er også koplet til en ADC-pinne på mikrokontrolleren. Strømmen kan da måles ved å lese av ADCen.

Som vi ser av skjemategningen går motorstrømmen over den 1 ohms store målemotstanden. Deretter blir signalet lavpassfiltrert, motoren er styrt med en 20 kHz PWM signal, og forsterket opp av en operasjonsforsterker. For å få strømovervåkning har utgangen fra operasjonsforsterkeren blitt lagt ut til en av mikrokontrollerens ADC innganger. Strømmen gjennom motoren kan da leses av ved å bruke formel \ref{eq:strom}. 

\begin{figure}[h]
\begin{lstlisting}
	/* Multiply K with ADC value to get current in 1/10 uA 
	* ADCref = 5 V
	* Aopamp = 15.7 (opamp gain)
	* K = ADCref * (100'000/1024)/(Aopamp) = 31
	*/
	uint16_t K = 31; 
	current_mA = (K*ADC)/100; //divide by 100 to get mA 
\end{lstlisting}
\label{eq:strom}
\end{figure}

For å teste kretsen ble det brukt en variabel strømforsyning. Modulen skrudde av strømmen ved riktig verdi og mikrokontrolleren leste av strømmen med stor nøyaktighet. 

\section{CAN}

Ifølge funksjonskravet WCF-02 skal protesen være styrt over PDCP-protokollen, som baserer seg på CAN for å sende og ta imot meldinger. Prototypekortet er utstyrt med en CAN-tranceiver, som deretter er koplet opp mot mikrokontrolleren. CAN-modulen ble testet med et USB til CAN-modul. Dette gjorde det enkelt å sende meldinger fra PCen. Mikrokontrolleren ble testet ved overføringshastigheter opp til 125 kbit. Da fungerte alt som forventet. 



\section{Diverse}

Diskuter tilkoblingskontakter her


\chapter{Programvare implementasjon}
\label{chap:sw}

Dette kapittelet beskriver hvordan programvaren er bygget opp og satt sammen. I tillegg diskuteres modulariseringen av koden og fallgruver ved programmering av et interrupt drevet system. Underkapitlene beskriver hva hver modul gjør og hvordan modulen forholder seg til resten av koden. 

Det som i hovedsak manglet ved overtagelsen av prosjektet var å skrive ferdig programvare til NRWDen. Det var skrevet drivere til de fleste modulene hvor koden var av varierende kvalitet, skrevet mer for å teste maskinvaren enn for å kunne brukes i det ferdige produktet. 

Den ferdige koden kan deles opp i to hoveddeler. Driverkoden til NRWDen som er maskinvareavhengig og høy nivå laget(HLL) til PDCP-protokollen. Driverkoden er igjen delt opp etter de ulike maskinvaremodulene. En oversikt over programvaren kan ses i figur \ref{fig:code_class_diagram}. Her vises alle de ulike modulene og hvem som inkluderer hvem. Det nederste laget er driverne til de forskjellige hardware modulene, current.h for strømovervåkning, position.h for posisjonssensoren, motor.h for motorstyring og can.h for det nederste laget av PDCP protokollen.

Selve implementasjonen av PDCP protokollen er en porting av programvare skrevet av  Andreas Nordal og Andrzej Zamojski i sine masteroppgaver \cite{bib:nordal,bib:zamojski}. 


\begin{figure}
\centering
\includegraphics[width=1.0\linewidth]{../Figurer/code_class_diagram}
\caption{Klassediagram som viser innholdet i og avhengighetene mellom de ulike programvare modulene.}
\label{fig:code_class_diagram}
\end{figure}

Systemet er for det meste drevet av interrupts, både interne og eksterne. Motorkommuteringen, posisjonsmålingen, motagelser av CAN-meldinger, fartsmåling og så videre skjer alle inni interruptrutiner. Når koden som kjører til en hver tid kan bli avbrutt av en interrupt rutine er det meget viktig å kode slik at det ikke oppstår race[?] kondisjoner. Den enkleste måten å forhindre dette på er å sørge for best mulig seperasjon mellom modulene, så ikke en modul kan endre på variabler brukt av en annen modul.


%Hva er faren ved å bruke interrupts? 

%Hva er gjort i forhold til race conditions?

%Optimalisering? Burde optimalisere for fart.

%Hvor mye av minnet bruker koden.

%Programflyt?




Under følger detaljer rundt hver modul. 

\section{Motor}

Motor-modulen sørger for kommuteringen av motoren og vinkelhastighetsavlesning.

Pådraget til motoren settes ved motor\_set\_speed(). Denne funksjonen setter dutycyclen til PWM-signalet som driver motoren. Siden strømmen levert av dette signalet varierer med forsyningsspenningen setter man ikke vinkelhastigheten direkte. Styringen av farten til protesen skjer inni controller-modulen. 

Etter at dutycyclen er satt vil Hall sensor interrupt rutinene automatisk ta seg av kommuteringen av motoren. En timer overflow interrup rutine vil kontinuerlig oppdatere vinkelhastigheten til protesen slik at den til enhver tid kan leses av med motor\_read\_speed().

\section{Current}

Current-modulen bruker mikrokontrollerens ADC til å lese av strømmen som går gjennom motoren. Interruptrutinen, CURRENT\_vect, som blir kjørt når maskinvaren skrur av strømmen til motoren ligger ikke her, men i main c-filen. Dette er fordi CURRENT\_vect benytter seg av flere av de andre maskinvaremodulene til å rydde opp i systemet etter at motorstrømmen har blitt skrudd av. 

\section{Position}

Position-modulen setter opp en timer til "input capture mode". Den er satt opp til å generere et interrupt ved endring i flanken på signalet fra posisjonssensoren. Ved en positiv flanke starter timeren og ved negativ flanke blir telleren i timeren lagret. Utifra verdien til telleren blir vinkelposisjonen til protesen regnet ut og lagret i en global variabel. Denne kan til en hver tid bli lest ut av position\_read funksjonen.  

\section{Controller}

Ifølge funksjonskravet WSF-01 skal bevegelsen til protesen være kontrollerbar gjennom de følgende måtene:

\begin{itemize}
\item On/Off-mode
\item Position mode
\item Velocity mode
\end{itemize}

Disse finnes implementert i controller.c som henholdsvis control\_on\_off(), control\_position() og control\_speed(). Utfordringen ved designet av regulatorene var at strømmen til motoren automatisk ble slått av hvis den oversteg en forhåndsbestemt maksgrense. En regulator som ikke hadde tatt hensyn til dette vil ikke ha gitt en god brukeropplevelse da protesemotoren ville skrudd seg av med gjevne mellomrom.  

Funksjonskravet WSF-01-01 sier at On/Off-mode skal være kjørt i en open-loop kontroller. På grunn av overnevnte grunner har den istedenfor blitt kjørt i en PI-kontroller. Denne regulerer strømmen gjennom motoren tett opptil den maksimale grensen for å oppnå høyest mulig vinkelhastighet. 

Fartsregulatoren løser begrensingen i motorstrøm ved å brukke en dobbel PI-regulator. Den ytre sløyfen tar inn vinkelhastighet og setter strøm referansen til den indre sløyfen. Den indre setter pådraget til motoren basert på strømreferansen og sørger samtidig for at strømmen ikke går over den maksimalt tillate verdien. 

Posisjonsregulatoren fungerer på samme måte som fartsregulatoren, bortsett fra at den ytre sløfen tar inn vinkelposisjonen til protesen. 

I alle regulatorene er utregningen av integralleddet uavhengig av frekvensen som regulatoren kjører på. Dette betyr at om frekvensen til regulatorløkken blir endret så må regulatorene justeres. Frekvensen til regulatorløkken er styrt med en busy-wait forsinkelse funksjon, se figur \ref{code:while_regulator}. Denne typen forsinkelsesfunksjoner registrerer ikke når man er inni en interruptrutine. Dette betyr at regulatorløkken blir forsinket med så mye tid man bruker inni hver av interruptrutinene. Da mikrokontrolleren bruker mindre enn 2\% av tiden sin inne interruptrutiner vil dette ikke medføre noen problemer for regulatoren. 

\begin{figure}[h]
\begin{lstlisting}
    while(1)
    {
	control_controller();
	_delay_ms(TIMESTEP);
    }
\end{lstlisting}
\caption{Main while loop}
\label{code:while_regulator}
\end{figure}

Verdien til P- og I-leddet til de tre regulatorene ble funnet vet å prøve å se hva som virket bra. De gir god regulering, men det kan med fordel brukes mer tid for å få enda bedre respons. 

Funksjonskravet WSF-03 setter krav til at man skal kunne skifte både regulatortype og vedien til regulatorparametrene gjennom PDCP-protokollen. Bytte av regulatortype gjøres gjennom control\_set\_mode() funksjonen. For å bytte parametere må man først velge regulator gjennom nevnte funksjon, deretter kan man sette P- og I leddet ved control\_set\_parameter() funksjonen. 


\section{Analog}


Funksjonskravet WCF-04 sier at NRWDen skal kunne styres ved å bruke analoge elektroder. Dette er den normale måten å styre myoelektriskeproteser. Videre sier WCF-02-01 at de analoge linjene skal kunne samples ved minst 1 kHz. Myoelektriske signaler har en båndbredde på 500 Hz. 

Analog-modulen ble ikke ferdig implementert i dette prosjektet. Hadde den blitt ferdig hadde den hatt de samme oppgavene som PDCP-modulen, ta imot eksterne signaler og styre protesen. 

Da kommunikasjonen ville vært rent analogt ville den ikke hatt like rik funksjonalitet som PDCP-protokollen. I sin enkleste form ville den kunne styre protesen i on/off-modus. 


\section{PDCP and can}

Når protesen er ferdig skal den kunne styres gjennom PDCP-protokollen. PDCP-protokollen er en åpen kilde protese kommunikasjonsprotokoll. Den har blitt til ved UNB i Canada og har som ambisjon og bli den nye standarden for protesekommunikasjon. 

I dette prosjektet har det blitt brukt en NTNU produsert PDCP-implementasjon. Den var oppdelt i to lag, et høynivå\cite{bib:nordal} lag som implementerte selve funksjonaliteten til protokollen og et maskinvare abstraksjonslag\cite{bib:zamojski} som var kodet for å være lett å tilpasse til ny maskinvare. 

I masteroppgaven\cite{bib:zamojski} knyttet til koden hevdes det at koden skal være lett å tilpasse til en mikrokontroller med intern CAN-kontroller. Dette var ikke min erfaring. Det ble brukt mye tid på å forsøke og kode om maskinvarelaget til å passe med AT90CAN mikrokontrolleren. Etter å ha jobbet mye med koden er min konklusjon at den er godt egnet om man bare skal skifte AVR mikrokontroller. Men fortsatt holde seg til den eksterne CAN-kontrolleren MCP2515, som koden har blitt designet rundt. 

Da man ikke greide å tilpasse det eksisterende maskinvare abstraksjonslaget ble det skrevet et nytt et som implementerte basis funksjonaliteten som krevdes for å teste ut PDCP-protokollen. Denne koden finnes i hal-c filen. Bruken av den interne CAN-kontrolleren er gjort med et åpent CAN bibliteket skrevet for AT90CAN mikrokontrolleren. Biblioteket består av filene can.c og can.h.


\section{Main}

Main starter med å initialisere de ulike modulene og velge kontrollertype. Det er i main-c filen at callback funksjonen fra PDCP-modulen er plassert, se kode \ref{code:pdcp_callback}. Callback funksjonen blir kalt fra PDCP-modulen hver gang den motar en melding.

\begin{figure}[h]
\begin{lstlisting}
 /* callback_incoming_can */
 /*
 * @fn 		void callback_incoming_can(struct socket *so)
 * @brief  	Callback function from HLL
 */
void callback_incoming_can(struct socket *so){
	
	struct can_msg *msg = sock_pull(so);
	switch(msg->function_code){

	case REQUEST_BIND:
	
	break;
	case RESPONS_BIND:
	
	break;
	case REQUEST_GET_INFO:
	
	break;
	
	...
\end{lstlisting}
\caption{Callback funksjonen som blir kalt fra PDCP-modulen hver gang den motar en melding.}
\label{code:pdcp_callback}
\end{figure}

Da dette prosjektet ble skrevet fantes det en PDCP-spesifikasjon\cite{bib:pdcp}, men ingen eksempel kode som viste hvordan de ulike PDCP-funksjonskodene skulle brukes. Det har blitt laget skjelettkode for å håndtere de ulike PDCP-funksjonskodene inni callbackfunksjonen. Når eksempel kode blir gjort tilgjengelig kan funksjonaliteten til de ulike kommandoene skrives ferdig.




\chapter{Diskusjon}



%Her bør man diskutere resultater fra:

\section{Arbeidsmetodikk}

%-arbeidsmetodikk Gantt

Som vår veileder flere ganger kommenterte. Et prosjekt uten noen arbeidsplan er som å regulere et system i åpen sløyfe; ting kan fort gå ut av kontroll. Planleggingen av dette prosjektet ble hjulpet ved bruk av gantt-diagrammet. Prosjektet ble startet med å dele opp arbeidet i deloppgaver. Hver oppgave ble gitt en anslått start- og sluttdato.  

Dette var svært nyttig da det tvang meg til å tenke på hvordan prosjektarbeidet skulle deles opp. Hvilke deloppgaver som bygget på hverandre og hvordan tiden skulle budsjetteres. Planen ble fulgt godt de første åtte ukene av prosjektet. Etter det gikk man mer eller mindre bort fra å bruke planen. Dette hadde flere grunner. Da planen først ble skrevet var det lettere å planlegge starten av prosjektet. Sluttfasen var mer uklar og ble dermed dårligere beskrevet i gantt-diagrammet. Dette gjorde det vanskligere å følge planen. For det andre hadde man, etter et halvt semester, mye bedre oversikt over prosjektet og følte ikke like stort behov for detaljplanlegging. 

\section{Mekanikken}

%-Mekanikk delen

Selve mekanikken i protesen har ikke vært fokuset i dette prosjektet. Men har blitt brukt for å teste om maskin- og programvaren fungerer. Det ble tidlig oppdaget problemer med mekanikken. Dette førte til at utviklingen av de ulike regulatorene ble forsinket. Da den ble tatt med til NTNU mekaniske verksted ble det oppdaget en bøyd girakse og slitt kulelager. Disse feilene kan tyde på at mekanikken ikke er robust nok til å brukes i praktiske eksperimenter. Det stilles også spørsmål til om motoren er riktig dimensjonert for de oppgaver protesen skal kunne utføre. Under testing av regulatorene skulle det ikke mye mekanisk motstand til før strømmen gjennom motoren oversteg maksimum grensen. Uten å ha målt det faktiske dreiemomentet til protesen anslåes det til for lite for praktiske oppgaver. Det anbefales, ved eventuell ny revisjon av mekanikken, at motoren byttes ut i en kraftigere utgave. 


\section{Implementasjon}

Et spørsmål til den nye maskinvarearkitekturen var den valgte mikrokontrolleren var hadde nok ressurser til å styre hele systemet. For detaljer rundt diskusjonen henvises det til kapittel \ref{chap:interrupt}. Hovedsaken her var om mikrokontrolleren ville ha god nok tid til å behandle systemets mange interruptkilder. Da systemet i hovedsak er interruptdrevet er kort responstid på interrupts kritisk for at systemet skal virke. Målinger viste at mikrokontrolleren brukte mindre enn 2\% av tiden inni ISRer. Dette er godt innenfor hva som er akseptabelt. 

Diskusjonene rundt maskinvaretesting og progamvare er gjort i kapittel \ref{chap:modTesting} og \ref{chap:sw}. 


\chapter{Konklusjon}

Det har i denne oppgaven blitt utviklet programvare for å styre NTNUs Rotary Wrist Device, en 1-akse håndleddsprotese. Koden har blitt skrevet for å kjøre på maskinvare laget av tidligere NTNU studenter. 

Systemet har blitt klargjort for å kunne bruke den åpne protese kommunikasjonsprotokollen PDCP. Implementasjonen av PDCP-protokollen for AVR hadde blitt gjort tidligere på NTNU. I denne oppgaven ble koden tilpasset for å kjøre på ATMELs AT90CAN128 mikrokontroller. 

Det har blitt skrevet programdrivere for alle de forskjellige maskinvaremodulene. For å styre bevegelsen til håndleddet har det blitt skrevet og testet tre ulike regulatorer. En fartsregulator, en posisjonsregulator og en av/på-regulator som kjører protesen ved maksimum vinkelhastihet i valgt retning. 

Da prosjektet ble overtatt var friksjon i mekanikken til protesen for stor til at den kunne brukes. Den ble tatt med til NTNUs mekaniske verksted hvor de fikk rettet en girakse som ga betydelig reduksjon av friksjon. 

Alt av overlevert maskinvare har blitt nøye testet. Forslag til forbedring av maskinvaren har blitt dokumentert.

Videre arbeide vil bestå i å fullføre integrasjonen med PDCP-protokollen. Dette avhenger av at det blir publisert flere detaljer rundt bruken av protokollen. Før protesen skal brukes i eksperimenter vil man ha stor nytte av å miniatyrisere kretsen slik at den får plass inni protesen. Under miniatyriseringen av kretsen anbefales det å utbedre maskinvaren med de anbefalinger gjort i denne oppgaven. 

Arbeidet på en analog kommunikasjonsmodul, som et alternativ til PDCP-modulen, har blitt påbegynt. 




\begin{thebibliography}{99}
\bibitem{bib:zink}
  Arthur Zinck,
  \emph{Design of a compact, reconfigurable, prosthetic wrist}.
  2011.
  
  
\bibitem{bib:stavdahl2002}
	Øyvind Stavdahl,
	\emph{Optimal wrist prosthesis kinematics: Three-dimensional rotation statistics and	parameter estimation.}
Department of Engineering Cybernetics, Norwegian University of Science and
Technology. 2002. PhD Thesis.  
  
\bibitem{bib:kraakenes}
  Andreas Kråkenes,
  \emph{Styresystem for kybernetisk håndleddsprotese}.
  Master i teknisk kybernetikk
  2011.
  
\bibitem{bib:nordal}
  Andreas Nordal,
  \emph{Implementasjon og testing av en åpen bussprotokoll for armproteser}.
  Master i teknisk kybernetikk
  2012.
  
\bibitem{bib:zamojski}
  Andrzej Zamojski,
  \emph{Design, Implementation and Testing of Low-level Layers of the PDCP for the AVR Platform}.
  Master i teknisk kybernetikk
  2012.
  
\bibitem{bib:brattbakken}
	Inge Brattbakken
	\emph{Embedded control system for cybernetic wrist prosthesis}
	Master of Science in Engineering Cybernetics
	2010.
	
\bibitem{bib:pdcp}
	Yves Losier
	\emph{Prosthetic Device Communication Protocol for the AIF UNB Hand Project}
	UNB Hand Project Systems Integrator
	2012.
	
\bibitem{bib:at90can}

	\emph{8-bit AVR Microcontroller with CAN controller AT90CAN128. Datablad.}
	Atmel
	
\bibitem{bib:bldc}
	
	\emph{Brushless DC-Servomotor, series 0620 B. Datablad}
	Faulhaber
	
	
	
\end{thebibliography}

\appendix

\chapter{Innhold CD}

\section{Rapport}

\begin{itemize}
\item Rapport pdf
\item Figurer brukt i rapport
\end{itemize}

\section{Programvare}

\begin{itemize}
\item main.c
\item motor.c, motor.h
\item current.c, current.h
\item position.c, position.h
\item controller.c, controller.h
\item analog.c, analog.h
\item PDCP-protokoll implementasjon
\item hal.c, hal.h
\item can.c, can.h
\end{itemize}


\section{Diverse}

\begin{itemize}
\item NRWD video
\item NRWD-RequirementsSpec\_v0.4
\item CAN-bibliotek
\end{itemize}


\chapter{Funksjonsspesifikasjon NRWD}

\begin{figure}
\centering
\includegraphics[width=1\linewidth]{../Figurer/NRWD-RequirementSpec_v0}
\caption{}
\label{fig:funkspes}
\end{figure}



\chapter{Diverse}


\begin{table}[h]
	\begin{center}
		\begin{tabular}{ | c | c |}
		\hline
			Duty cycle &  Vinkelhastighet \\ \hline
			80	& 156 grader/sekund\\ \hline
			65	& 94 grader/sekund\\ \hline
			50	& 44 grader/sekund\\ \hline
		\end{tabular}
	\end{center}
\caption{Vinkelhastighet til NRWDen ved ulike duty cycles, 12V spenningsforsyning}
\label{tab:velocity}
\end{table}


\end{document}